---
title: 2025-10-26
author: 길지운
date: 2025-10-26
category: TIL/길지운/2025/10
layout: post
---

### 1일 1아티클
#### Data Methods
###### SQL 안티패턴
**배경**
- 안티패턴 : 피해야 할 나쁜 습관/방식
- 쿼리, 데이터 파이프라인 유지보수 어려워짐
- 데이터 신뢰도 및 성능 저하
  
**안티패턴 종류**
1. 과도한 `CASE WHEN` 구문
  - 수백 개의 애플리케이션 상태 코드를 사람이 읽을 수 있는 값으로 변환하는 긴 `CASE WHEN` 구문 필요한 상황
  - 문제 : 빠르게 대시보드 생성을 위해, 이 긴 로직을 특정 대시보드 전용 View 안에 두는 것
  - 근거 : 로직이 중앙화되지 않아 일관성을 잃고 재사용성 저하
  - 해결책 : 별도의 **차원 테이블**이나 **공용 뷰**로 생성하여 관리
2. 인덱스가 걸린 컬럼에 함수 사용
  - 인덱스가 설정된 컬럼을 `WHERE` 절에서 조회하는 상황
  - 문제 : 해당 컬럼에 함수 적용 (ex. `WHERE UPPER(name) = 'ABC'`)
  - 근거 : DB는 해당 컬럼의 원본 값을 기준으로 인덱스 생성, 이를 함수로 변형시킬 경우 인덱스 활용 불가
  - 해결책 : 비교하려는 **값**을 변경하여 함수 사용 지양 / 필요시, 함수 기반 인덱스로 미리 생성
3. View에서 `SELECT *` 사용
  - 뷰를 만드는 상황
  - 문제 : 편리하다는 이유만으로 모든 컬럼을 선택하는 쿼리를 사용하는 습관
  - 근거 : 스키마 변경에 취약, 불필요한 리소스 낭비
  - 해결책 : 뷰 생성 시 **필요한 컬럼**만 명시적으로 지정
4. 중복 제거를 위한 `DISTINCT` 남용
  - 잘못된 조인으로 중복 데이터 발생한 상황
  - 문제 : 상황을 해결하고자 `SELECT DISTINCT` 사용하여 덮어버리는 경우
  - 근거 : `DISTINCT`는 근본 원인을 무시하는 임시방편, 이후 집계 시 데이터 불일치 문제 발생
  - 해결책 : **조인 로직 자체를 검토**하고 수정하여 중복의 원인 제거
5. 과도한 View 중첩
  - 뷰를 만드는 상황
  - 문제 : View A 기반으로 다른 View B 생성, View B 기반으로 다른 View C 생성, ...
  - 근거 : 의존성 관계 복잡도 증가로 관리 어려워짐, 성능 저하 및 디버깅 난도 상승
  - 해결책 : 주기적으로 변환 로직 단순화, 무거운 로직은 **테이블**이나 **구체화된 뷰**로 생성
6. 많은 일을 하는 중첩 서브쿼리
  - 서브쿼리를 작성하는 상황
  - 문제 : 서브쿼리를 3~4겹 이상 깊이 중첩하여 사용, 하나의 서브쿼리가 많은 필터링 및 집계 동시 처리
  - 근거 : 쿼리 로직 복잡성 증가로 디버깅 난도 상승, 가독성 저하
  - 해결책 : CTE(`WITH` 절) 사용으로 논리성 및 가독성 향상
  
> 작은 편법들이 시간이 지나며 쌓이는 것이 안티패턴. 처음부터 쿼리 명확성을 위해 몇 분 더 고민할 것!
{: .block-tip}
  
### 오늘 배운 것
1. AI 관통 프로젝트
  - 파인튜닝(con.)
  - 모델을 SOTA 버전으로 하고 싶었으나, 용량 문제 발생...
  
### 내일 할 일
1. 
  
### 참고자료
- [SQL Anti-Patterns You Should Avoid](https://datamethods.substack.com/p/sql-anti-patterns-you-should-avoid)