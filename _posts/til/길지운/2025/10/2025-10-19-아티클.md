---
title: 2025-10-19
author: 길지운
date: 2025-10-19
category: TIL/길지운/2025/10
layout: post
---

### 1일 1아티클
#### LY
###### 문을 없애고 테스트하기
**사례**
```kotlin

  // IntAdder : 정수 합계 저장, flush 시 리셋 직전의 합계 반환과 함께 리셋
  val adder = IntAdder()

  adder.add(1)
  adder.add(2)
  println(adder.flush()) // Shows 3

  adder.add(100)
  adder.add(200)
  println(adder.flush()) // Shows 300

  class IntAdder {
      private var currentSum: Int = 0

      fun add(value: Int) {
          currentSum += value
      }

      fun flush(): Int {
          val result = currentSum
          currentSum = 0
          return result
      }
  }

```
  
**문제 상황**
```kotlin

  // 단위 테스트 생성을 위해 테스트에서만 가시성 변경
  class IntAdder {
      var currentSum: Int = 0
          @VisibleForTesting internal get
          private set
  }

  // Unit test code
  adder.add(100)
  assertEquals(100, adder.currentSum)

  adder.add(200)
  assertEquals(300, adder.currentSum)

  assertEquals(300, adder.flush())
  assertEquals(0, adder.currentSum)

```
1. `IntAdder` 가 사양 변경에 따라 속성이 바뀔 경우 → 여전히 `add`, `flush` 테스트가 유효해야 함 (현재 `currentSum` 속성이 변경되어 기존 테스트 컴파일 X)
  
> 단위 테스트에서 확인해야 할 것  
> 1. 함수의 반환값 및 예외  
> 2. 외부에서 제공되는 객체와의 상호작용 (실제 인수나 생성자 인수로 입력된 객체, 주입된 객체, etc.)
{: .block-tip}
  
**개선 방안**
1. `currentSum` 이라는 내부 값을 들여다보는 대신, 함수의 반환값을 테스트하도록 수정
  
```kotlin

  // Unit test code
  adder.add(100)
  adder.add(200)
  assertEquals(300, adder.flush())
  assertEquals(0, adder.flush())

```
  
2. 외부에서 제공되는 객체와 상호작용하려면?
  - mock을 활용하여 함수 호출 검증
  - 외부 제공 객체가 테스트 환경에 포함되어 있고, 테스트 대상 함수 관찰만이 목적일 경우 실제 객체 사용 가능
  
> 단위 테스트에서는 내부 세부 작동보다, **사양에 맞게** 작동하는지 확인할 것
{: .block-tip}
  
### 오늘 배운 것
  
### 내일 할 일
1. AI
2. 바이브 프로젝트 기능 개발
  
### 참고자료
- [코드 품질 개선 기법 4편: 문을 없애고 테스트하기](https://techblog.lycorp.co.jp/ko/techniques-for-improving-code-quality-4)