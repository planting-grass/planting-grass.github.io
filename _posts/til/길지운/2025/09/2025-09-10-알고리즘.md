---
title: 2025-09-10
author: 길지운
date: 2025-09-10
category: TIL/길지운/2025/09
layout: post
---

### 1일 1아티클
#### Geeknews
###### 클로드 사용 방식
**핵심 아이디어**
- 클로드가 코딩을 자동화하는 동안, 나는 PM/디자이너/소프트웨어 설계자 등 더 중요한 역할 수행
- 클로드를 채팅창으로 대하는 것이 아닌, 결과물을 예측 가능하고 가치 있게 만드는 규칙/역할/워크플로우의 집합으로 여기는 것.
  
**클로드 설정 디자인**
1. 작업은 어디에 있는가?
   - 마크다운 백로그 : 마크다운으로 작성된 할 일 목록 (ex. Backlog.md, ReqText, etc.)
   - 구조화된 텍스트 : 작업으로 변환되는 제품 사양 (ex. Agent OS)
   - 이슈/티켓 : 사양을 Github Issue 또는 Jira Ticket으로 저장, 코드 검토에 연결 (ex. ccpm)
   > 작업은 클로드가 볼 수 있고 추적할 수 있는 곳에 위치해야 함
   {: .block-tip}
2. 클로드를 어떻게 안내하는가?
   - 명령어 라이브러리 : 미리 정의된 명령어 (ex. /create-tasks, /review, etc.)
   - 코딩 표준 : 명확한 기술 스택, 코딩 가이드라인
   - 완료의 정의 : "완료의 정의"를 인코딩
   - 트리거 검증 후크 : 모든 변경 사항에 대해 린팅 및 테스트 적용
   - 리뷰어로서의 Claude : 개발자이면서 동시에 리뷰어로서의 Claude
   > 규칙이 명확하고 반복 가능할 때 클로드는 더 나은 성과를 냄
   {: .block-tip}
3. 에이전트들은 어떻게 협력하는가?
   - 역할 시뮬레이션 : PM, 아키텍트, 개발자, 테스터로서의 AI (ex. Agent OS)
   - 군집 병렬성 : 많은 에이전트가 구조화된 흐름(사양→의사코드→코드→테스트)으로 동시 실행 (ex. Claude-Flow)
   - 저장소 기반 아티팩트 : 작업, 로그, ADR을 코드 베이스에 저장해 메모리가 지속되도록 함 (ex. Roo Commander)
   > 협력은 많은 AI 근로자들이 충돌하지 않도록 방지
   {: .block-tip}
4. 세션은 어떻게 진행되는가?
   - 터미널 오케스트레이션 : 클로드는 명령, 창, 로그 제어 (ex. Symphony, Claud-Squad)
   - 병렬 작업 트리 : Git Worktrees를 사용하여 여러 브랜치 병렬 실행 (ex. Crystal)
   - 병렬 컨테이너 : 충돌을 피하기 위해 격리된 컨테이너에서 Claude 실행 (ex. ClaudeBox)
   > 지속적인 충돌 없이 병렬로 작업을 실행하여 더 많은 작업을 빠르게 완료
   {: .block-tip}
5. 코드는 어떻게 도구에 접근하는가?
   - MCP 통합 : Claude를 외부 리소스(브라우저, DB, Test Runner, UI 자동화 프레임워크, etc.)에 연결하는 MCP 서버
   - 사용자 정의 도구 라이브러리 : 내장된 셸 스크립트 및 명령 (ex. Symphony)
   - 데이터베이스 접근자 : 강력한 DB 액세스를 위한 도구 (ex. Supabase를 사용한 Claudable)
   - 테스트 및 검증 후크 : 작업이 완료되었다고 선언 전에, 테스트(ex. Vitest, Jest) 실행 (ex. Agent OS)
   > 툴링은 클로드를 작업 확인 및 시스템과 상호 작용 가능한 "활동적인 팀원"으로 업그레이드해줌
   {: .block-tip}
6. 코드는 어떻게 개발되는가?
   - PM : 제품 사양을 작업 및 백로그로 전환 (ex. ccpm, Agent OS)
   - 아키텍트 : 코딩 시작 전에 전반적인 구조 설계, 인터페이스 정의, 규칙 설정
   - 구현자 : 테스트와 표준을 준수한 가드레일 내에서 코드 작성
   - QA : 문제에 대한 작업 검토 (ex. BMAD code)
   - 검토자 : PR의 품질, 가독성, 위험성 검사
   > 소프트웨어 수명 주기의 각 단계에서 AI 활용
   {: .block-tip}
7. 코드는 어떻게 전달되는가?
   - 사소한 차이점 : AI가 티켓을 수집하여 작은 PR 생성, 항상 검토 (ex. ai-ticket)
   - 실험 : 기능 플래그 뒤에 변경 사항 배포
   - 전체 앱 스캐폴드 : AI는 상위 레벨 프롬프트에서 전체 앱 빌드, 배포 (ex. Claudable)
   > 규모 선택 필요 → 생산성을 위한 안전한 반복, 프로토타입을 위한 스캐폴드
   {: .block-tip}
8. 맥락은 어떻게 보존되는가?
   - 문서 및 저널 : `CLAUDE.md`, 아키텍처 노트, 프로젝트 저널 최신 상태 유지 (ex. Claude Conductor)
   - 지속적인 기억 및 점검 : 최근 작업 요약, 프로젝트 상태 점검, 결정 사항 저장 (ex. Claude-Flow)
   > AI는 기억이 없으면 실수 반복, 기억을 할 때 발전이 가속화됨
   {: .block-tip}
  
**추가로 고려할 옵션**
- 초보자 설정 : 마크다운 백로그 + 티켓 차이점
- 구조화된 팀 : 제품 사양 + 표준 + 역할 시뮬레이션
- 실험이 많을 때 : 저장소 아티팩트 + 병렬 세션
- 프로토타입 모드 : 앱 빌더 + 문서 스캐폴딩
  
> AI는 **구조를 제공**할 때 가장 잘 작동!
{: .block-tip}
  
> 클로드는 개발자를 대체하는 것이 아님 → 그들의 역할을 바꾸는 것
{: .block-tip}
  
### 오늘 배운 것
1. 알고리즘
  - swea 5643 키순서
  - 플로이드 워셜
  
### 내일 할 일
1. 포트폴리오 내용 복기
  
### 참고자료
- [클로드 코드 프레임워크 전쟁](https://shmck.substack.com/p/claude-code-framework-wars)