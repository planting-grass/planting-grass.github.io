 ---
 title: 2025-11-03
 author: 강병호
 date: 2025-11-03
 category: TIL/강병호/2025/11 (파일 경로 : TIL/{이름}/{연}/{월})
 layout: post (자유)
 ---

트랜잭션 : 하나의 논리적인 작업 set에서  쿼리의 수와 관계 없이 논리적인 작업 (세트) 자체가 100% 적용되거나 아무것도 적용되지 않음 을 보장해주는 것

즉, 쿼리의 수보다는 논리적인 작업이라는 단어에 집중해야한다.

**왜 필요한가?**

대부분의 OS, DB 등의 개념에서는 이런 복잡한 기능이 들어가게 되는 이유는 **개발자의 편의** 에서 비롯 된다. 이러한 트랜잭션 기능은 애플리케이션단의 개발에서 발생하는 문제들을 해결해준다.

**MyISAM vs InnoDB**

MyISAM은 트랜잭션을 지원하고 InnoDB는 트랜잭션을 지원하지 않는다. 이런 상황에서 트랜잭션이 왜 필요한지를 살펴보자.

```sql
// 1. MyISAM
CREATE TABLE
	tab_myisam ( fdpk INT NOT NULL, PRIMARY KEY (fdpk) )
	ENGINE=MyISAM;

// 1. InnoDB
CREATE TABLE
	tab_innodb ( fdpk INT NOT NULL, PRIMARY KEY (fdpk) )
	ENGINE=INNODB;

// 2. Insert 3
INSERT INTO tab_myisam (fdpk) VALUES (3);
INSERT INTO tab_innodb (fdpk) VALUES (3);

// 3. AUTO-COMMIT active
SET autocommit=ON;

// 4. Insert 1 2 3
INSERT INTO tab_myisam (fdqk) VALUES (1), (2), (3);
INSERT INTO tab_innodb (fdqk) VALUES (1), (2), (3);
```

위와 같은 방식으로 MyISAM, InnoDB의 실행과정을 비교해보자.

1. MyISAM, InnoDB 엔진으로 각각 테이블 생성
2. 두 테이블에 3이라는 데이터 Insert
3. auto commit 활성화
4. 1, 2, 3 데이터 삽입

위 과정을 수행하게 된다면 4번의 과정에서 `ERROR 1062 (23000) : Duplicate entry '3' for key 'PRIMARY`  에러를 마주하게 된다. 이는 pk키 중복 오류로 인해 쿼가 실패한 것이다.

그렇다면 여기서 각 테이블의 레코드를 조회해보면 `tab_myisam` 테이블의 경우 1, 2, 3 의 키가 남겨져 있음을 `tab_innodb` 테이블은 3만이 남아 있음을 확인할 수 있다.

innodb는 쿼리 중 일부라도 오류가 발생 시 전체를 원 상태로 만드는 Rollback의 과정을 수행했기에 그대로 복구된 것이고 MyISAM은 이러한 특성을 가진 트랜잭션 기능이 없기에 Insert문이 실행되면서 1, 2가 저장된 상태를 그대로 두고 쿼리 실행을 종료하는 것이다. 이를 **부분 업데이트**라고 부르고 이는 테이블 데이터 정합성을 맞추는 데에 어플리케이션 개발자들에게 어려움을 제공한다.

실제 각 DBMS를 기준으로 개발을 한다는 기준으로 실패에 대한 재처리 작업은 엔진별로 다음과 같이 처리된다.