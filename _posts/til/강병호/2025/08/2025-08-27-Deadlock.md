 ---
 title: 2025-09-27
 author: 강병호
 date:  2025-09-27
 category: TIL/강병호/2025/08
 layout: post (자유)
 ---

# **Deadlock 에 대해 설명해 주세요.**

여러 프로세스가 서로 자원을 기다리며 무한히 대기하는 상태에 빠지는 것을 의미한다.

- Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.
    1. 상호 배제 : 자원이 이미 다른 프로세스에 의해 사용 중인 경우, 다른 프로세스가 그 자원의 해제가 이루어질 때 까지 기다리는 것 
    2. 점유 대기 : 자원을 점유한 상태에서 추가 자원을 요청할 때 발생하는 것으로 추가로 요청하는 자원이 해제될 때까지 기다리는 것이다.
    3. 비선점 : 다른 프로세스가 점유하는 자원을 강제로 가져가는 것이 불가능한 것으로 점유하고 있는 프로세스가 자발적으로 해제하는 것을 기다리는 것이다.
    4. 순환 대기 : N개의 프로세스가 존재할 때 자원 대기 현상이 원형을 이루는 것으로 P1 → R2, P2 → R3, Pn → R1 을 대기하는 현상을 말한다.
- 그렇다면 3가지만 충족하면 왜  Deadlock 이 발생하지 않을까요?
    1. 상호 배제 조건이 없는 경우 : 하나의 자원을 여러 프로세스가 동시에 사용할 수 있기에 프로세스가 대기할 필요가 없다.
    2. 점유 대기 조건이 없는 경우 : 프로세스가 자원을 점유한 상채에서 다른 자원을 요청할 수 없기에 자원을 점유한 프로세스가 추가적인 자원 요청으로 인한 대기 상태 큐로 넘어가지 않는다.
    3. 비선점 조건이 없는 경우 : 자원을 요청하는 프로세스가 필요한 자원을 점유하지 못한 경우 다른 프로레스로 부터 자원을  선점할 수 있는 경우이다. 이는 프로세스가 자원을 기다리는 DeadLock을 벗어날 가능성이 높아진다.
    4. 순환 대기 조건이 없는 경우 : 대기 상태에 있는 프로세스들이 서로 자원을 기다리는 상황이 발생하지 않기에 DeadLock이 발생하지 않는다.
- 어떤 방식으로 예방할 수 있을까요?
    
    위에서 언급된 4가지 조건 중 하나만 충족하지 않도록 한다. 
    
- 왜 현대 OS는 Deadlock을 처리하지 않을까요?
    
    DeadLock을 처리하게 되면 모든 자원고 락을 실시간으로 추적하면서 추후의 요청을 예측해야 한다. 이는 시스템의 성능에 크게 영향을 끼치기 때문에 유저 스페이스에서 처리하도록 한다.
    
- Wait Free와 Lock Free를 비교해 주세요.
    
    **Wait Free**
    
    - 모든 스레드가 제한된 수의 단계 안에 작업을 완료할 수 있음을 보장하는 알고리즘으로 시스템 전반의 처리량을 보장하며 모든 스레드가 계속해서 진행되도록 한다.
    
    **Lock Free**
    
    - 여러 스레드가 공유 자원에 접근가능하며 하나의 스레드가 실패, 지연되어도 다른 스데르가 계속해서 진행되도록 한다.
