 ---
 title: 2025-10-27
 author: 강병호
 date: 2025-10-27
 category: TIL/강병호/2025/10 (파일 경로 : TIL/{이름}/{연}/{월})
 layout: post (자유)
 ---

### 인덱스

데이터를 빠르게 찾기 위한 탐색용 자료구조로 보통 **B+Tree** 구조

테이블 전체를 순차 검색(Full Scan)하지 않고 `user_id` 인덱스 트리를 따라가 O(log n) 탐색 가능

종류

- 클러스터형 인덱스
    - 인덱스가 데이터 그 자체로 존재한다. 즉, 리프 노드에 실제 데이터가 저장된다. 결국 테이블의 실제 데이터 정렬을 물리적 순서로 정렬한다.
    - 인덱스 트리 = 데이터 자체
        
        ```java
        B+Tree
        ┌──────────────┐
        │ Root         │
        │  (key=100)   │
        ├──────────────┤
        │ Leaf Nodes   │
        │ 100 | Record of ID=100 |
        │ 101 | Record of ID=101 |
        │ 102 | Record of ID=102 |
        └──────────────┘
        ```
        
        - 리프 노드 자체에 실제 레코드 저장 → 인덱스 저렬 순서로 물리적 저장
            - 100 101 102
- 비클러스터형 인덱스
    - 인데그삭 데이터의 별도 복사본으로 데이터의 주소가 리프 노드에 저장도니다. 결국 실제 데이터가 정렬되어 있지 않는 데이터 순서 유지가 되지 않음
    - 인덱스 트리= 실제 데이터 주소를 가리킨다.
    
    ```java
    B+Tree
    ┌──────────────┐
    │ Root         │
    │ (key=100)    │
    ├──────────────┤
    │ Leaf Nodes   │
    │ 100 | → pointer to record |
    │ 101 | → pointer to record |
    │ 102 | → pointer to record |
    └──────────────┘
    
    ```
    
    - 데이터 위치 주소만 저장 하여 실제 데이터는 다른 순서 저장
    - 클러스터형 인덱스 예시
        
        ```java
        CREATE TABLE users (
            id INT PRIMARY KEY,
            name VARCHAR(50),
            age INT
        );
        ```
        
        - `id` 컬럼이 클러스터형 인덱스 역할로 데이터가 id 순으로 실제 저장되어 정렬
