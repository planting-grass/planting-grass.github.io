---
title: TIL
author: 곽영헌
date: 2025-12-2
category: TIL/곽영헌/2025/12
layout: post
---

#7 네트워크 심화

# 7-1 안정성을 위한 기술, 확장

더 많은 사용자를 받기위해 물리적 장비나 프로그램을 여러개 두는 `이중화`, `다중화`

트래픽을 고르게 분산하는 `로드밸런싱`

## 가용성

안정성을 `특정 기능을 언제든 균일한 성능으로 수행할 수 있는 특성`으로 정의한다면, 이를 수치화 하여 나타내는 용어를 `가용성` 이라고 한다.

가용성이란 `컴퓨터 시스템이 특정 기능을 실제로 수행할 수 있는 시간의 비율`을 의미한다.

가용성 = (업타임)/(업타임+다운타임) 으로 정의한다.

고가용성은 영어로 HA라고도 한다.

일반적으로 `안정적` 이라고 얘기하는 수준은 99.999%. 9가 다섯개이므로 `파이브 나인스` 라고 한다.

다운타임이 1년에 5.26분, 1개월 26.3초

결국 핵심은 `결함 감내` 능력을 키우는것. fault Tolerance

## 이중화

무언가를 이중으로 두는 것. 백업을 마련하는 방법.

그 무언가는 다양하다. 서버, NIC, 스위치 ,DB, 웹서버...

`문제가 발생할 경우 시스템 전체가 중단될 수 있다` 에서 문제가 되는 부분을 `단일 장애점 SPoF Single Point Of Failure` 라고 한다.

이중화 구성에는 2가지 종류가 있다

- 액티브/스탠바이
    하나는 가동, 나머지는 백업으로 대기

    성능이득은 없다. 스탠바이로 자동 전환을 `페일 오버` 라고 한다.


- 액티브/액티브
    두개 다 가동

    부하 분산의 성능 이득, 그러나 하나가 터지면 나머지로 몰려 부하가 심해진다.


3개 이상이면 다중화다.


이중화/다중화의 사례로 `티밍 teaming` 과 `본딩 bonding` 이 있다.

전자는 윈도우, 후자는 리눅스에서 사용된다.

여러 NIC을 다중화하여 뛰어나고 안정적인 하나의 인터페이스처럼 보이게 한다.1Gbps 3개를 묶어 3Gbps로 동작하게 한다.


## 로드밸런싱

일반적으로 고가용성을 요구하는 주체는 클라이언트보다는 서버다. 서버를 다중화 하더라도, 트래픽 분배를 해결해야 한다. 가용성에 큰 영향을 끼치기 때문이다.

사전적 의미로는 `주어진 시점에 네트워크를 경유한 데이터의 양` 이지만, 일반적으로 표현하면 `주어진 시점에 특정 노드를 경유한 패킷의 양` 을 의미한다.

서버를 다중화 하더라도, 많은 트래픽으로 인해 가용성이 떨어진다. 

로드밸런싱은 로드 밸런서에 의해 수행되며, `L4스위치`, `L7스위치` 라 불리는 장비로도 동작하나, 로드밸런싱 소프트 웨어를 설치하면 일반 호스트도 로드밸런서로 동작할수있다. 

대표적으로 HAProxy, Envoy, Nginx


다중화된 환경에서 서버에 문제가 생긴걸 감지하기 위해 로드밸런서에 의해 헬스체크가 일어난다. 
HTTP, ICMP등 다양한 프로토콜을 쓸 수 있다. 

로드밸런서 주도의 헬스체크 이외에 서버간에 하트비트 라는 메세지를 주기적으로 주고받기도 한다. 서버끼리 하트비트 하다가 끊기면 문제발생

로드밸런싱 알고리즘에는

- 라운드 로빈

- 최소 연결(연결이 적은 서버부터 우선적으로 부하를 전달)

- 무작위

- 해시 이용

- 응답시간이 가장 짧은 서버


서버마다 성능이 다르다면, 가중치를 줄수도 있다.


*** 질문 1

헬스체크는 로드밸런서가 여러 서버에 요청을 보내고 응답을 받는식으로 일어나는데, 왜 옵저버 패턴이라던지 PUBSUB을 도입하지 않았을까

정답 1. 서버가 죽으면 못보냄

실제로 그런 방식은 따로 있음. 
서비스 디스커버리
1. MSA환경에서는 서버가 시작되면 나 떴다고 레지스트리 서버에 등록한다. 여기서도 하트비트가 있어서 서버가 주기적으로 살아있다고 신호를 보낸다


1. 수동적인 헬스체크도 있음. 주기적으로 찌르진 않겠는데, 만약 실제 요청을 보냈을때 500 뱉으면 그때 널 빼겠다 

## 좀더알아보기 - 포워드 프록시와 리버스 프록시

프록시를 포워드 프록시, 게이트웨이를 리버스 프록시 라고도 부른다.

사전적으로 보면

`프록시` 는 `클라이언트가 선택한` 메세지 전달 대리자. 주로 캐시 저장, 클라이언트 암호화 및 접근 제한의 기능을 한다.
`게이트웨이` 는 일반적으로는 `네트워크 간의 통신을 가능케 하는 입구 역할의 하드웨어` 지만, HTTP중간서버라는 맥락에선 이렇다.
`아웃바운드 연결에 대해 오리진 서버 역할` `인바운드 요청에 대해 다른 인바운드 서버들로 전달하는 중개자` 역할

# 7-2 : 안정성을 위한 기술, 보안

## 암호와 인증서

암호화 = encrypt
복호화 = decrypt

핵심은 Key

### 대칭키, 비대칭키 암호화

대칭키 = 비공개키 암호화

암호화와 복호화에 동일한 Key 사용, 따라서 상대방에게 안전하게 Key를 전달하는게 관심사
가만 보면, 애초에 키를 안전하게 전달할 수 있다면 그냥 그렇게 메세지를 보내면 되기때문에 약간 애매함. 그래서 비대칭키=공개키 암호화

비대칭키 = 공개키 암호화

암호화를 위한 키와 복호화를 위한 키가 다르다

암호화를 위한 공개키와, 복호화를 위한 개인 키.

그래서 A->B에서 A는 B에게 공개키를 요구한다. 공개키로 암호화 하고, B만 가지고 있는 개인키로 복호화
B->A할때도 B는 A의 공개키를 받아 암호화 하고, A만 가진 개인키로 복호화

---

대칭키는 키를 안전하게 전송하기 어렵지만, 적은 부하. 공개키는 암호화 및 복호화에 시간이 많이 들지만, 키가 안전

보통 함께 사용하는 경우가 많다

대칭키를 안전하게 전달하기 위해 공개키로 대칭키를 암호화 하고, 개인키로 암호화된 대칭키를 복호화.

이렇게 활용되는 대칭키를 세션키 라고도한다.





### 인증서와 디지털 서명

인증서란 일반적으로 `공개 키 인증서` 를 말한다. 이게 해커가 보낸 공개키가 아니라, 진짜 키구나.

인증서는 `인증기관` 이라는 제 3의 기관이 발급한다. 일반적으로 CA라고 한다.CA가 발급한 인증서에는 서명값이 있어서 이걸로 인증서를 검증할 수 있다.

서명값은 1. 인증서 내용에 대한 해시 값을 2. CA의 개인 키로 암호화 하는 방식으로 만들어진다. CA는 이 정보를 서명값으로 삼아 클라이언트에게 인증서와 함께 전송한다.

1의 결과를 지문(finger print) 라고도 한다.

클라이언트는 

1. 인증서 내용과 서명값으로 분리한다.
1-1 . 서명값을 CA의 공개키로 복호화 한다.
1-2. 인증서 내용을 인증서에 명시된 해시함수로 해시한다.

1-1과 1-2를 비교하여 인증서의 유효성을 판단한다.

### HTTPS: SSL과 TLS

SSL/TLS는 인증과 암호화를 수행하는 알고리즘. TLS는 SSL을 계승한 프로토콜. , SSL/TLS를 사용하는 HTTPS.

주로 사용되는건 TLS 1.3 

HTTPS 메세지는 3단계를 거친다

1. TCP 3-way 핸드셰이크
2. TLS 핸드셰이크
3. 암호화된 메시지 송수신

1. TCP 3-way
하던거. 

2. TLS 핸드셰이크
우선 암호화 통신을 위한 키를 교환한다. .
인증서 송수신과 검증이 이뤄진다.

우선 ClientHello로 클->서로 전송.
이때 암호화된 통신을 위해 서로 맞춰봐야할 정보를 제시한다. 가능한 TLS버전, 사용 가능한 암호화 방식과  해시 함수. 키를 만들기 위해 사용할 클라이언트의 난수.

`사용가능한 암호화 방식과 해시함수`를 담은 정보를 `암호 스위트` 라고 한다.

---
서버는 응답으로 ServerHello를 전송한다.
제시된 정보를 선택한다. 

사전협의 정보를 통해 암호화에 사용할 키를 만들어 낸다.
이 이후 키로 암호화된 암호문을 주고받는다.

---

또 서버는 Certificate 메세지와 CertificateVerify 메세지를 전송한다. 각각 인증서와 디지털 서명을 의미한다.
클라이언트는 이 메세지를 토대로 서버의 공개키를 검증한다. 
이어서 TLS 핸드셰이크의 마지막을 의미하는 Finished 메세지를 주고받는다.

이제 암호화된 데이터 전송

---

*** 고난이도 질문

내 데스크탑에는 윈도우와 리눅스가 듀얼부팅으로 되어있다.
이번에 블루투스 키보드를 샀는데 다음과 같은 현상이 일어난다.

1. 윈도우와 페어링, 사용 굿
2. 리눅스와 페어링, 사용 굿
3. 윈도우로 돌아왔더니, 연결이 거부됨
4. 이를 해결하기 위해 장치 제거 후 다시 페어링하니까 됐는데, 리눅스로 재부팅하면 리눅스에서 또 안됨

왜 이런 현상이 일어났을까

힌트 1 : 블루투스는 블루투스 랜카드의 MAC주소를 사용하여 통신을 한다. 
힌트 2: 블루투스는 대칭키 암호화를 이용한다.
힌트 3: Key 생성이 어디서 일어날지.

A1. 원인 분석 "문제의 핵심은 **'식별자(MAC)는 같은데 암호키(Link Key)가 달라졌기 때문'**입니다."

하드웨어 식별: 윈도우와 리눅스는 같은 하드웨어를 쓰므로, 키보드에게 보내는 MAC 주소가 동일합니다. 키보드는 두 OS를 **'동일한 컴퓨터'**로 인식합니다.

키 불일치:

윈도우에서 페어링할 때 Key_A를 생성해 공유했습니다.

리눅스에서 페어링할 때 Key_B를 새로 생성했습니다.

키보드는 "아, 컴퓨터(MAC)가 암호를 Key_B로 바꿨구나"라고 생각하고 Key_A를 덮어씁니다.

인증 실패: 다시 윈도우로 오면, 윈도우는 여전히 Key_A를 내밀지만, 키보드는 Key_B만 알고 있으므로 "암호가 틀렸다"며 연결을 거부합니다.

A2. 해결 방안 "두 OS가 **동일한 대칭키(Link Key)**를 공유하도록 만들면 됩니다."

윈도우와 리눅스 각각 페어링을 한 번씩 진행합니다. (최신 상태의 키를 확보하기 위함)

**가장 마지막에 페어링한 OS(예: 리눅스)**의 키 값을 확인합니다.

그 키 값을 복사해서, 연결이 안 되는 OS(윈도우)의 레지스트리나 설정 파일에 덮어씌웁니다.

이렇게 하면 키보드, 윈도우, 리눅스 셋 다 하나의 동일한 대칭키를 가지게 되어, 어느 OS로 부팅하든 재페어링 없이 연결됩니다.

# 7-3 : 무선 네트워크

## 전파와 주파수

전파 혼재를 막기위해 주파수 대역이 존재한다.

자연환경으로 발생한 주파수가 우연히 겹처 지지직 하곤 한다.
오늘날 LAN환경에서의 무선통신은 IEEE 802.11로 표준화 되어있다.

이 표준은 대부분 2.4GHz, 5GHz 대역을 사용한다.

## 와이파이와 802.11

근데 같은 대역이라도 여러 와이파이가 있는데 이게 왜 가능할까

채널이라 불리는 하위 주파수 대역으로 또 세분화된다. 물론 아날로그같은거라 간섭의 여지가 있으므로, 채널로도 좀 떨어진걸 선택하는게 좋고, 너무 많은 와이파이가 없는게 좋다.

## AP와 서비스 셋

무선 네트워크를 생성하기 위해서는 무선 액세스 포인트 `AP`가 필요하다. 

무선 LAN의 기기들은 AP를 경유해 통신한다. 

AP를 경유해 통신하는 방식을 `인프라스트럭처 모드` 라고 한다.

AP간섭없이 호스트끼리 통신하는걸 `애드 혹 모드` 라고한다.

이렇게 부분 네트워크로 묶이는걸 서비스 셋이라고 한다.

서비스 셋 끼리 구분하기 위해 SSID를 사용한다.와이파이 이름이 SSID다.

