---
title: 2025-08-20
author: 조수아
date: 2025-08-20
category: TIL/조수아/2025/08
layout: post
---

# 오늘 배운 것

# 5.1 트랜잭션

- 트랜잭션 : 데이터의 정합성 보장
    - 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용하는 현상이 발생하지 않게 만들어주는 기능
- 잠금 : 동시성 제어 기능
    - 여러 커넥션에서 동시에 동일한 자원(레코드나 테이블)을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할
- 격리 수준
    - 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨

## 5.1.1 MySQL에서의 트랜잭션

- 트랜잭션 : 하나의 논리적인 작업 셋에 몇 개의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용 되거나 아무것도 적용되지 않아야 함을 보장
- 부분 업데이트 : 논리적인 작업 셋에서 중간에 실패 했을 때 변경된 사항들이 롤백 되지 않은 것
    - 실패한 쿼리로 인해 남은 레코드를 다시 삭제하는 재처리 작업이 필요

## 5.1.2 주의사항

- 트랜잭션은 DBMS 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.
- 특히 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다.

# 5.2 MySQL 엔진의 잠금

- MySQL 잠금
    - 스토리지 엔진 레벨
        - 스토리지 엔진 간 상호 영향을 미치지 않음
    - MySQL 엔진 레벨
        - 스토리지 엔진을 제외한 나머지 부분
        - 모든 스토리지 엔진에 영향을 미침
        - 종류
            - 테이블락 : 테이블 데이터 동기화
            - 메타데이터락 : 테이블의 구조를 잠금
            - 네임드락 : 사용자의 필요에 맞게 사용가능한 잠금

## 5.2.1 글로벌 락

- MySQL에서 제공하는 잠금 가운데 가장 범위가 큼
    - MySQL 서버 전체
    - MyISAM이나 MEMORY 테이블에 대해 백업 할 때 사용
- 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태
- InnoDB는 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경작업을 멈출 필요 없음 → 가벼운 글로벌 락 필요 ⇒ 백업락 도입
- 백업락 : 백업 툴들의 안정적인 실행을 위한 잠금
    - 특정 세션에서 백업락 획득 시 테이블 스키마나 사용자의 인증 관련 정보 변경 불가
        - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경 삭제
        - REPAIR TABLE, OPTIMIZE TABLE 명령 (테이블 점검/복구/최적화시 사용)
        - 사용자 관리 및 비밀번호 변경
    - 일반적인 테이블의 데이터 변경은 허용
    - 왜?
        - MySQL 서버 구성 : 소스 서버 + 레플리카 서버
        - 백업은 레플리카 서버에서 실행
        - 데이터 변경까지 막으면 소스에 문제 발 생시 레플리카에 최신 변경사항을 다시 적용해야함 → 즉 변경사항 다 적용 될 때까지 백업 지연
        - 그렇다고 잠금을 막으면 스키마 변경 시도시에 백업 실패함
        - 따라서 백업락은 일반적인 테이블의 데이터 변경은 허용하되, 스키마나 사용자 인증 관련 정보는 변경 불가

## 5.2.2 테이블 락

- 개별 테이블 단위로 설정되는 잠금
    - 명시적 : `LOCK TABLES table_name [READ | WRITE]` 명령으로 특정 테이블의 락 획득
        - `UNLOCK TABLES`  명령으로 잠금 반납(해제) 가능
        - 특별한 상황이 아니라면 애플리케이션에서 사용할 필요 거의 없음
            - 왜? → 온라인 작업에 상당한 영향을 미침
    - 묵시적
        - InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인한 묵시적 테이블락이 설정되지 않음
        - 더 정확히는 테이블 락이 설정되는 경우는 스키마를 변경하는 DDL의 경우에만 영향을 미침

## 5.2.3 네임드 락

- `GET_LOCK()`  함수를 이용해 임의의 문자열에 대해 잠금을 설정
    - 대상 : 테이블, 레코드 , AUTO_INCREMETN 같은 객체가 아닌 사용자가 지정한 문자열
    - 사용 목적
        - 여러 클라이언트가 상호 동기화를 처리해야할 때
        - 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션
            - 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 네임드 락을 걸고 쿼리를 실행하면 아주 간단히 해결 가능

## 5.2.4 메타데이터락

- 테이블이나 뷰 등의 데이터 베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금
- 명시적으로 획득/해제 불가하고 테이블 이름 변경과 같은 쿼리 실행시 자동으로 획득