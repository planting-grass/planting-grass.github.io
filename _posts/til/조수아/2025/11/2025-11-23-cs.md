---
title: 2025-11-23
author: 조수아
date: 2025-11-23
category: TIL/조수아/2025/11
layout: post
---

# 오늘 배운 것

- **데이터베이스(DB)란?**
    
    데이터를 효율적으로 저장·조회·관리하기 위한 구조화된 데이터 저장소다.
    
- **DBMS란?**
    
    데이터베이스를 생성·접근·관리하는 소프트웨어로, 대표적으로 MySQL·PostgreSQL·Oracle이 있다.
    
- **스키마(Schema)란?**
    
    데이터베이스의 구조와 제약조건을 정의한 논리적 설계도다.
    
- **정규화(Normalization)란?**
    
    데이터 중복을 줄이고 이상현상(삽입·삭제·갱신)을 방지하기 위해 테이블을 구조화하는 과정이다.
    
- **역정규화(Denormalization)란?**
    
    조회 성능을 위해 일부 중복을 허용하고 테이블을 합치는 등 정규화를 일부 풀어주는 작업이다.
    
- **트랜잭션(Transaction)이란?**
    
    DB에서 논리적으로 하나의 작업 단위이며, ACID 특성을 만족해야 한다.
    
- **ACID란?**
    
    원자성·일관성·고립성·지속성을 의미하며 트랜잭션 신뢰성을 보장한다.
    
    일관성 : 트래잭션 전후의 제약조건들이 깨지지 않고 항상 일관된 상태 유지
    
    고립성 : 여러 트랜잭션이 동시에 실행되도 서로 간섭 x
    
    격리 수준 고려
    
    지속성 : 키밋 이후에 장애가 나도 데이터가 남는것
    
- **격리 수준(Transaction Isolation Level)이란?**
    
    동시에 실행되는 트랜잭션 간 간섭을 제어하는 단계로, Read Uncommitted → Read Committed → Repeatable Read → Serializable 순으로 강해진다.
    
    리드 언 커밋티드 : 커밋 되지 않은 값도 읽음 더티 리드 발생
    
    리드 커밋티드 : 커밋된 데이터만 읽지만 셀렉트 두번하면 값 달라질 수 잇음
    
    리피터블 리드 : 하나의 트랜잭션 동안 같은행을 항상 같은 값으로 읽음
    
    팬텀 리드가 발생할 수 있지만 갭락, 넥스트키락으로 막을 수 있음
    
    시리얼라이저블 : 트랜잭션을 직렬처럼 순차 실행하듯 보장
    
    모든 동시성 문제 해결하지만 성능 최악
    
    | 격리 수준 | Dirty Read | Non-repeatable Read | Phantom Read | 특징 |
    | --- | --- | --- | --- | --- |
    | **1. Read Uncommitted** | ❌ 발생 | ❌ | ❌ | 거의 사용 X |
    | **2. Read Committed** | ⭕️ 방지 | ❌ 발생 | ❌ | **오라클 기본**, “실시간 최신 데이터만 보자” |
    | **3. Repeatable Read** | ⭕️ | ⭕️ 방지 | ❌ (일반적으로 발생) | **MySQL InnoDB 기본**; MVCC로 읽기 일관성 보장 |
    | **4. Serializable** | ⭕️ | ⭕️ | ⭕️ | 완벽하지만 성능 최악, 사실상 SELECT에 Lock 걸림 |
- **Non-repeatable Read란?**
    
    같은 쿼리를 두 번 읽을 때 결과가 달라지는 현상이다.
    
- **Phantom Read란?**
    
    같은 조건으로 SELECT했는데 트랜잭션 중 새 행이 나타나는 현상이다.
    
- **인덱스(Index)란?**
    
    데이터를 빠르게 찾기 위해 별도 자료구조(B-Tree 등)를 유지하는 구조로 조회는 빠르지만 쓰기 비용이 증가한다.
    
- **클러스터형 인덱스(Primary Index)란?**
    
    테이블 자체가 인덱스 순서대로 정렬되는 방식이며, PK가 클러스터 키가 된다.
    
- **보조 인덱스(Secondary Index)란?**
    
    별도의 인덱스 페이지에 키와 Row Pointer를 저장하는 일반 인덱스다.
    
- **조인(Join)이란?**
    
    여러 테이블의 행을 조건에 따라 결합하는 연산으로 Nested Loop, Hash Join, Merge Join 방식이 있다.
    
    | 조인 | 핵심 아이디어 | 언제 빠름? | 언제 느림? |
    | --- | --- | --- | --- |
    | **Nested Loop** | 한 행씩 찾아보기 | 작은 + 인덱스 있음 | 전체 스캔 필요할 때 |
    | **Hash Join** | 해시 버킷으로 O(1) 조회 | 대용량 + 인덱스 없음 | 메모리 제한, 해시 충돌严重 |
    | **Merge Join** | 정렬 후 병합 | 정렬된 데이터 + 범위조인 | 정렬 비용이 큰 경우 |
    
    “Nested Loop는 한쪽 테이블을 한 행씩 읽으며 다른 테이블에서 인덱스로 찾는 방식이라 작은 테이블 + 인덱스가 있을 때 유리합니다.
    
    Hash Join은 해시 테이블 기반으로 대용량에도 빠르지만 = 조인에서만 가능하고 메모리를 많이 씁니다.
    
    Merge Join은 정렬된 두 테이블을 병합하듯 조인해서 대량 데이터의 범위 조인에도 잘 맞습니다.”
    
    블록 네스티드 루프 조인은 기본 Nested Loop 조인을 최적화한 방식으로,
    
    Outer 테이블을 한 행씩 읽지 않고 여러 행을 블록 단위로 메모리에 올려 처리합니다.
    
    그 덕분에 디스크 I/O가 크게 줄어 기본 NLJ보다 훨씬 빠릅니다.
    
    인덱스가 없을 때 선택될 수 있지만, 해시 조인보다는 덜 효율적일 수 있습니다.
    
- **뷰(View)란?**
    
    쿼리 결과를 논리적 테이블처럼 사용하는 객체로, 실제 데이터는 저장하지 않는다.
    
- **스토어드 프로시저(Stored Procedure)란?**
    
    DB에 저장되는 함수·프로그램으로, 복잡한 로직을 DB 내부에서 처리할 수 있다.
    
- **샤딩(Sharding)이란?**
    
    대용량 데이터를 수평으로 여러 DB 서버에 분산 저장하는 방식이다.
    
- **파티셔닝(Partitioning)이란?**
    
    하나의 테이블을 조건에 따라 물리적으로 분리해 저장하는 방식이다.
    
    | 구분 | 파티셔닝 | 샤딩 |
    | --- | --- | --- |
    | **나누는 레벨** | 테이블 내부 | DB 서버 자체 |
    | **DB 개수** | 1개 | 여러 개 |
    | **주 목적** | 성능 최적화 / 관리 | 수평 확장 / 트래픽 분산 |
    | **관리 책임** | DB 내부 기능 | 애플리케이션 + 인프라 |
    | **JOIN** | 자유로움 | 어렵거나 불가 |
    | **스케일** | 싱글 노드 | 수평 확장 |
- **락(Lock)이란?**
    
    여러 트랜잭션의 동시 접근을 제어하여 정합성을 유지하는 메커니즘이다.
    
- **Optimistic Lock이란?**
    
    충돌이 적은 환경에서 버전 확인 방식으로 동시성을 제어하는 방식이다.
    
- **Pessimistic Lock이란?**
    
    충돌을 대비해 데이터 접근 시점에 바로 락을 거는 방식이다.
    
- **커버링 인덱스(Covering Index)란?**
    
    필요한 컬럼이 전부 인덱스에 포함되어 있어 테이블 접근 없이 인덱스만으로 조회되는 구조이다.
    
- **Oracle vs MySQL vs PostgreSQL**
    - Oracle: **안정성·동시성 최강, 비싸고 무거움**
    - MySQL: **빠르고 가볍고 웹 서비스 최적화**
    - PostgreSQL: **기능 가장 강력, 고급 쿼리/정합성 중심**
    - **Oracle**
        - **장점**
            - 트랜잭션·락·동시성 처리 최강, 대규모 기업 환경에 안정적, 기능 풍부, 상업 지원 탄탄함.
        - **단점**
            - 라이선스 비용 매우 높음, 운영 난이도 높음.
        - **언제 쓰나?**
            - 금융·공공기관·초대형 트랜잭션 시스템.
    - **MySQL**
        - **장점**
            - 오픈소스, 빠르고 가볍고 안정적, 웹 서비스 최적화, InnoDB로 트랜잭션 지원, 생태계 풍부.
        - **단점**
            - 고급 기능 부족(특수 연산, 복잡한 쿼리), 락/동시성 처리 PostgreSQL 대비 약함.
        - **언제 쓰나?**
            - 스타트업·웹 서비스·고성능 읽기/쓰기 트래픽 중심 서비스.
    - **PostgreSQL**
        - **장점**
            - 오픈소스 DB 중 기능 가장 풍부함, SQL 표준 준수율 최고, 복잡한 쿼리·트랜잭션·JSON 모두 강함.
        - **단점**
            - MySQL보다 운영 난이도가 높고 튜닝이 어려울 수 있음.
        - **언제 쓰나?**
            - 데이터 정합성과 복잡한 SQL이 중요한 시스템, 머신러닝/분석/지도/검색 데이터.
    - 면접 답변
        
        제가 프로젝트를 진행하면서 Oracle, MySQL, PostgreSQL을 각각 사용해본 경험이 있습니다. 
        
        Oracle은 학교에서 제공된 인프라로 써봤는데, 트랜잭션 처리나 락 매커니즘이 굉장히 안정적이라는 느낌을 받았습니다.
        
        다만 문법이 표준 SQL과 조금 다른 부분이 있어서 학습 부담이 있었고, 전체적으로 무겁고 설정이 까다로워서 빠르게 개발하기엔 제약이 있다는 점을 느꼈습니다. 
        
        MySQL은 웹 백엔드를 개발할 때 가장 많이 사용했는데, 가볍고 속도도 빠르고 JPA 같은 ORM과도 안정적으로 연동돼서 실제 개발 생산성이 가장 좋았습니다. 오류 메시지도 직관적이고 운영 경험이 많아 정보도 풍부해 신입 입장에서 가장 편했습니다.
        
        다만 복잡한 쿼리나 JSON 연산 같은 고급 기능은 부족하다는 한계를 느꼈습니다.
        
        PostgreSQL은 기능이 굉장히 강력하다는 게 인상적이었습니다. JSON 타입, 윈도우 함수 등 MySQL보다 표현력이 좋아서 데이터 분석이 필요했던 프로젝트에서 특히 도움이 됐습니다.
        
        다만 MySQL보다 초기 세팅과 튜닝 난이도가 높아 운영 경험이 적으면 진입 장벽이 있다는 점도 체감했습니다.
        
        전체적으로 Oracle은 안정성, MySQL은 개발 편의성, PostgreSQL은 기능적 표현력이 강하다는 차이를 경험했습니다.