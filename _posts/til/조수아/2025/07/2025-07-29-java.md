---
title: 2025-07-29
author: 조수아
date: 2025-07-29
category: TIL/조수아/2025/07
layout: post
---

# 오늘 배운 것
## 형변환
- 산술 이항 연산자는 연산 전에 피 연산자의 타입을 일치 시킨다!
  - 만약 피연산자의 크기 4Byte(int) 미만이면 int로 변경한 후 연산 진행
  - 혹은, 두 개의 피연산자 중 큰 타입으로 형 변환 후 연산 진행

## 비트 연산자 vs 논리 연산자
### short-circuit(단축 평가)
- `&`, `|`: 비트 연산자  
  - short-circuit 안 함 → 양쪽 다 계산
- `&&`, `||`: 논리 연산자  
  - short-circuit 함  
  - `&&` → 앞이 false면 뒤 안 함  
  - `||` → 앞이 true면 뒤 안 함

## 조건문
- 조건문 괄호에 들어갈 수 있는 것 -> boolean
- switch문 괄호에 들어갈 수 있는 것 -> byte, shor, char, int, String
  - long, double, float 사용 불가
  - switch는 내부적으로 tableswitch 또는 lookupswitch라는 정수 기반 jump table로 변환되어 int 값 기준으로 작동하기 때문에 long은 지원하지 않음
  - switch expressions
    - 표현식 자체가 값을 반환가능하여 자동 break해줌
    - 실행할 라인이 1줄인 경우 ':'를 빼고 '->'를 이용해 처리
    - 만약 여러 줄이면 yield키워드 사용
    - 동일하게 처리되는 여러 조건을 쉼표로 구분하여 한 라이에서 처리 가능
  - String을 이용한 switch 주의사항
    - 파라미터.equals("A") 이런식으로 작동
    - 만약 파라미터가 null이면 NullPointerException 발생 따라서 사용시 주의!

## 배열
- 배열 : 동일한 타입의 데이터 0개 이상을 하나의 연속된 메모리 공간에서 관리하는 것
  - 배열도 참조형 변수!
  - 배열.length -> 이때 length 는 상수!
  - 생성시 기본값으로 초기화됨
  - 배열의 크기는 불변하여, 최초 메모리 할당 이후 크기 변경은 불가능
    - 값변경은 가능!
  - 배열 복사 method
    - System.arrayCopy(Object srcm, int scrPos, Object dest, int destPos, int length)
    - Arrays.copyOf(int[] original, int newLength)
- String -> char[], int[]
  - String.charAt(i) : i번째 인덱스 값 char로 가져오기
  - String.charAt(i) - '0' : 문자 0을 빼서 값 가져오기(아스키코드로 문자 0은 48)
- 배열 만들기
  - 생성과 동시에 할당한 값으로 초기화 전부 가능
    ```
      int[] b = new int[] {1, 3, 5, 6, 8}; // o
      int[] c = {1, 3, 5, 6, 8}; // o
    ```
  - 선언과 생성을 따로 처리할 경우 반드시 생성 필요
    ```
    int[] points;
    points = {1, 3, 5, 6, 8};  //컴파일 오류
    int[] points;
    points = new int[]{1,3,5,6,7}; //선언할 때는 배열의 크기를 알 수 없을 때
    ```
- for-each 배열 사용 가능
  - 단 복사된 값이므로 read-only

## 2차원배열
- 선언
  - int [][] intArray;
  - int intArray [][]
  - int [] intArray[]
    -> 3개 다 가능!
  - 선언과 동시에 값 할당 가능
    {% raw %}
    int [][] intArray = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}, {9, 10, 11}};
    {% endraw %}
  - 2차원 배열 선언 후 1차 배열만 생성 후 2차 배열은 필요에 따라 생성 가능
    - 단 반드시 2차 배열을 생성해야되지 바로 값 할당은 안됨
      - ```int intArray[][] = new int[4][3];``` ✅
      - ```int[] intArray2[] = new int[][3];``` ❌ 잘못된 차원 지정
      - ```int[][] intArray3 = new int[4][];``` ✅ (2차원 배열이지만 내부 배열은 아직 null)
      - ```int[][] intArray4 = new int[4]{1,2,3};``` ❌ 문법 오류 ← 틀린 부분
      - {% raw %}int[][] intArray5 = new int[][]{{1,2,3},{1,2,3},{1,2,3},{1,2,3}};{% endraw %} ✅
      - {% raw %}int[][] intArray6 = {{1,2,3},{1,2,3},{1,2,3},{1,2,3}};{% endraw %} ✅

## 객체지향프로그래밍
- 주변의 많은 것들을 객체화해서 프로그래밍 하는 것
- 장점
  - 신뢰성 높은 프로그래밍 가능
  - 추가/수정/삭제가 용이
  - 재사용성 높음
- 특징 : 추상화, 다형성, 상속, 데이터 은닉과 보호

## 추상화(Abstraction)
- 추상화 : 현실의 객체를 추상화해서 클래스를 구성한다

## class와 object
- 현실 세계의 객체를 -(추상화)-> 클래스
- 클래스를 -(구체화)-> 객체(instance)

## JVM
- meta-space : 클래스 정보처리
  - 타입 정보
  - field 정보
  - method 정보
  - 상수 풀
- stack : 메서드들의 실행 공간
  - thread 별로 별도 관리
  - 메서드 호출 시 마다 메서드 프레임 적층
  - 메서드 프레임에 로컬 변수도 쌓이는 구조
- heap : 객체를 저장하기 위한 영역
  - thread에 의해 공유
  - 객체가 생성되고 G.C에 의해 정리됨

## 변수
- 멤버 변수
  - 클래스 멤버 변수
    - 선언 위치 : 클래스 영역 + static
    - static : 거의 변하지 않지만 변할 수도 있다
    - 클래스 로더에 의해 클래스가 로딩될 때 상수 풀에 구성됨
    - 클래스가 언로드 될 때 GC 발생
    - 클래스 이름으로 접근 가능
  - 인스턴스 멤버 변수
    - 선언 위치 : 클래스 영역
    - 초기화 : 타입 별로 default 초기화 이후 할당된 값으로 명시적 초기화
    - 객체가 생성 될 때 heap에 객체 별로 생성됨 -> 즉 각 객체 별로 변수의 값이 고유함
    - GC에 의해서 객체가 없어질 때 소멸되어 프로그래머가 명시적으로 소멸 불가능
    - 객체 이름으로 접근 가능
- 지역 변수
  - 선언된 라인이 실행될 때 스택의 메서드 프레임 내부에 생성
  - 사용하기 전 명시적 초기화가 필요
  - 외부에서 접근이 불가하므로 소속이 불필요하고 내부에서는 이름으로 바로 접근
  - `{}` 을 벗어나면 소멸
  - 지역 변수
    - 선언 위치 : 함수 내부
  - 파라미터 변수
    - 함수 선언부

## 메서드
- 메서드 사용 이유 : 반복적으로 사용되는 코드의 중복을 방지할 수 있다.
- 파라미터를 전달할 때왁 값을 반환할 때 묵시적 형변환이 적용된다
- variable argument
  - 메서드 선언 시 동일 타입의 인자가 몇개 들어올지 예상할 수 없을 경우 사용
  - 배열 타입은 메서드 호출전 배열을 생성하고 초기화 해야하지만 가변 인수를 사용하면 그러한 번거로움 해결
  - `...`을 이용해 선언하면 호출시 넘겨준 값의 개수에 따라 자동으로 배열 생성 및 초기화
- 기본형 변수와 참조형 변수
  - 메서드 호출 시 파라미터로 입력된 값을 복사해서 전달
  - 즉 call by value

## 메서드 오버로딩
- 메서드 오버로딩 : 동일한 기능을 수행하는 메서드를 추가 작성하는 것
  - 장점 : 기억해야할 메서드가 감소하고 중복 코드에 대한 효율적인 관리 가능
  - 구현
    - 메서드 이름은 동일
    - 파라미터의 개수 또는 순서, 타입이 달라야 할 것

## 생성자
- 생성자 코드가 클래스 내부에 없으면 기본 생성자 제공
  - 즉 생성자 코드가 있으면(예: 파라미터가 있는 생성자) 기본 생성자는 없어짐 만약 필요하다면 기본 생성자 입력해줘야함

## this
- this 는 객체에 대한 참조를 의미
- this() : 자기 객체 생성자
  - 반드시 첫 줄에서만 호출이 가능

## 초기화 블록
- 멤버 변수의 초기화를 목적으로함
- `{}`를 이용해 내부에 실행 코드 작성
- 이름이 없으므로 별도로 호출이나 파라미터를 받을 수 없음
- 종류
  - 클래스 초기화 블록
    - 클래스 멤버 변수(클래스 안 static 변수) 초기화에 사용
    - 클래스 로딩 후 1회 호출됨
  - 인스턴스 초기화 블록
    - 인스턴스 멤버 변수 초기화 시 사용
    - 객체 생성 -> new 사용 -> 다음에 호출되어 이후 -> 생성자 코드 실행

## 구성요소의 로딩 순서
- static
  1. static 변수 로딩 -> 기본 초기화
  2. static method 로딩
  3. static initializer 실행
  4. static method 중 main 실행
- instance
  1. 멤버 변수 로딩 -> 기본 초기화
  2. instance initializer 실행
  3. 생성자 호출
# 내일 할일
- 과목 평가/월말 평가 잘보기..
- 해커톤 보고서 완료하기
- 알고리즘 모의역량, 삼성 기출 문제 풀기

# 참고 자료