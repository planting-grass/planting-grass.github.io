---
title: 2025-07-29
author: 조수아
date: 2025-07-29
category: TIL/조수아/2025/07
layout: post
---

# 오늘 배운 것
## 형변환
- 산술 이항 연산자는 연산 전에 피 연산자의 타입을 일치 시킨다!
  - 만약 피연산자의 크기 4Byte(int) 미만이면 int로 변경한 후 연산 진행
  - 혹은, 두 개의 피연산자 중 큰 타입으로 형 변환 후 연산 진행
## 비트 연산자 vs 논리 연산자
### short-circuit(단축 평가)
- &, | : 비트 연산자
  - short-circuit 안함! 따라서 양쪽 다 계산
- &&, || : 논리 연산자
  - short-circuit 함
  - && -> 앞이 false면 뒤 안함
  - || -> 앞이 true면 뒤 안함
## 조건문
- 조건문 괄호에 들어갈 수 있는 것 -> boolean
- switch문 괄호에 들어갈 수 있는 것 -> byte, shor, char, int, String
  - long, double, float 사용 불가
  - switch는 내부적으로 tableswitch 또는 lookupswitch라는 정수 기반 jump table로 변환되어 int 값 기준으로 작동하기 때문에 long은 지원하지 않음
  - switch expressions
    - 표현식 자체가 값을 반환가능하여 자동 break해줌
    - 실행할 라인이 1줄인 경우 ':'를 빼고 '->'를 이용해 처리
    - 만약 여러 줄이면 yield키워드 사용
    - 동일하게 처리되는 여러 조건을 쉼표로 구분하여 한 라이에서 처리 가능
  - String을 이용한 switch 주의사항
    - 파라미터.equals("A") 이런식으로 작동
    - 만약 파라미터가 null이면 NullPointerException 발생 따라서 사용시 주의!
## 배열
- 배열 : 동일한 타입의 데이터 0개 이상을 하나의 연속된 메모리 공간에서 관리하는 것
  - 배열도 참조형 변수!
  - 배열.length -> 이때 length 는 상수!
  - 생성시 기본값으로 초기화됨
  - 배열의 크기는 불변하여, 최초 메모리 할당 이후 크기 변경은 불가능
    - 값변경은 가능!
  - 배열 복사 method
    - System.arrayCopy(Object srcm, int scrPos, Object dest, int destPos, int length)
    - Arrays.copyOf(int[] original, int newLength)
- String -> char[], int[]
  - String.charAt(i) : i번째 인덱스 값 char로 가져오기
  - String.charAt(i) - '0' : 문자 0을 빼서 값 가져오기(아스키코드로 문자 0은 48)
- 배열 만들기
  - 생성과 동시에 할당한 값으로 초기화 전부 가능
    ```
      int[] b = new int[] {1, 3, 5, 6, 8}; // o
      int[] c = {1, 3, 5, 6, 8}; // o
    ```
  - 선언과 생성을 따로 처리할 경우 반드시 생성 필요
    ```
    int[] points;
    points = {1, 3, 5, 6, 8};  //컴파일 오류
    int[] points;
    points = new int[]{1,3,5,6,7}; //선언할 때는 배열의 크기를 알 수 없을 때
    ```
- for-each 배열 사용 가능
  - 단 복사된 값이므로 read-only
## 2차원배열
- 선언
  - int [][] intArray;
  - int intArray [][]
  - int [] intArray[]
    -> 3개 다 가능!
  - 선언과 동시에 값 할당 가능
    ``` 
    int [][] intArray = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}, {9, 10, 11}};
    ```
  - 2차원 배열 선언 후 1차 배열만 생성 후 2차 배열은 필요에 따라 생성 가능
    - 단 반드시 2차 배열을 생성해야되지 바로 값 할당은 안됨
      - ```int intArray[][] = new int[4][3];``` ✅
      - ```int[] intArray2[] = new int[][3];``` ❌ 잘못된 차원 지정
      - ```int[][] intArray3 = new int[4][];``` ✅ (2차원 배열이지만 내부 배열은 아직 null)
      - ```int[][] intArray4 = new int[4]{1,2,3};``` ❌ 문법 오류 ← 틀린 부분
      - ```int[][] intArray5 = new int[][]{{1,2,3},{1,2,3},{1,2,3},{1,2,3}};``` ✅
      - ```int[][] intArray6 = {{1,2,3},{1,2,3},{1,2,3},{1,2,3}};``` ✅
## 객체지향프로그래밍
- 주변의 많은 것들을 객체화해서 프로그래밍 하는 것
- 장점
  - 신뢰성 높은 프로그래밍 가능
  - 추가/수정/삭제가 용이
  - 재사용성 높음
- 특징 : 추상화, 다형성, 상속, 데이터 은닉과 보호
## 추상화(Abstraction)
- 추상화 : 현실의 객체를 추상화해서 클래스를 구성한다
## class와 object
- 현실 세계의 객체를 -(추상화)-> 클래스
- 클래스를 -(구체화)-> 객체(instance)
## JVM
- meta-space : 클래스 정보처리
  - 타입 정보
  - field 정보
  - method 정보
  - 상수 풀
- stack : 메서드들의 실행 공간
  - thread 별로 별도 관리
  - 메서드 호출 시 마다 메서드 프레임 적층
  - 메서드 프레임에 로컬 변수도 쌓이는 구조
- heap : 객체를 저장하기 위한 영역
  - thread에 의해 공유
  - 객체가 생성되고 G.C에 의해 정리됨
## 변수
- 멤버 변수
  - 클래스 멤버 변수
    - 선언 위치 : 클래스 영역 + static
    - static : 거의 변하지 않지만 변할 수도 있다
  - 인스턴스 멤버 변수
    - 선언 위치 : 클래스 영역
    - 객체가 생성 될 때 heap에 객체 별로 생성됨 -> 즉 각 객체 별로 변수의 값이 고유함
    - GC에 의해서 객체가 없어질 때 소멸되어 프로그래머가 명시적으로 소멸 불가능
- 지역 변수
  - 지역 변수
    - 선언 위치 : 함수 내부
  - 파라미터 변수
    - 함수 선언부

# 내일 할일
- 과목 평가/월말 평가 잘보기..
- 해커톤 보고서 완료하기
- 알고리즘 모의역량, 삼성 기출 문제 풀기
# 참고 자료