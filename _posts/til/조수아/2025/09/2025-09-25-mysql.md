---
title: 2025-09-25
author: 조수아
date: 2025-09-25
category: TIL/조수아/2025/09
layout: post
---

# 오늘 배운 것

# MySQL 조인 방식 비교 정리

## ❓ 질문 포인트

1. **MMR(Sort-Merge Join)** 은 정렬이 필요해서 오버헤드가 발생한다고 배웠다.
2. **BNLJ(블록 네스티드 루프 조인)** 은 드라이븐 테이블 기준으로 동작하므로, 드라이븐 테이블이 크면 오버헤드가 발생할 수 있다.
3. 그렇다면 어떤 경우에 더 오버헤드가 큰가?
4. 옵티마이저가 이 상황에서 알아서 조인 방식을 선택해 주는가?

---

## 🔹 1. Sort-Merge Join (MMR)

- **특징**
    - 조인 키 기준으로 두 테이블을 정렬 후 병합.
- **장점**
    - 두 테이블이 이미 정렬되어 있거나 인덱스가 잘 걸려 있으면 효율적.
- **단점**
    - 정렬 비용이 크면 메모리·디스크 오버헤드 발생.

---

## 🔹 2. 블록 네스티드 루프 조인 (BNLJ)

- **특징**
    - 드라이빙 테이블 블록을 읽어 메모리에 올려두고,
        
        드라이븐 테이블을 반복 스캔하며 조인.
        
- **장점**
    - 인덱스 없어도 사용 가능.
- **단점**
    - 드라이븐 테이블이 크면 디스크 I/O 폭발 → 성능 저하.

---

## 🔹 3. 오버헤드 비교

- **드라이븐 테이블이 큰 경우** → BNLJ가 더 부담됨 (I/O 문제).
- **정렬이 필요한 경우** → MMR이 더 부담됨 (정렬 비용 문제).
- 즉, 데이터 분포·인덱스 상태에 따라 다르며, 절대적인 우열은 없음.

---

## 🔹 4. 옵티마이저의 판단

MySQL 옵티마이저는 **통계 정보**를 기반으로 자동 선택:

- **인덱스 있음** → Nested Loop Join 선호.
- **인덱스 없음 + 작은 드라이빙 테이블** → BNLJ 고려.
- **정렬 필요 + 대규모 데이터** → MMR 고려.

👉 결국 옵티마이저가 상대 비용을 계산해 가장 저렴한 방식을 선택.

단, 항상 완벽하지 않으니 `EXPLAIN` 으로 실행 계획 확인 권장.