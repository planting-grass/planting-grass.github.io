---
title: 2025-10-31
author: 조수아
date: 2025-10-31
category: TIL/조수아/2025/10
layout: post
---

# 오늘 배운 것

## 📌 시스템 콜이란?

> 사용자 프로그램이 운영체제(OS)의 커널 기능을 사용하기 위해 
**커널에 요청을 전달하는 인터페이스**
> 

즉, 유저 프로그램이 하드웨어나 OS 자원에 직접 접근 못 하니까
**“OS야! 이거 대신 해줘!”** 라고 요청하는 **공식 통로**야.

---

## 🧠 왜 필요한가요?

- 사용자 프로그램은 **User Mode**에서 실행됨 (제한된 권한)
- 하드웨어 제어나 파일 접근, 메모리 할당 등은 **Kernel Mode**만 가능
- 이때 **시스템 콜을 통해 커널에게 위임**해서 요청함

---

## 📂 시스템 콜의 종류

| 분류 | 예시 시스템 콜 | 설명 |
| --- | --- | --- |
| 프로세스 제어 | `fork()`, `exec()`, `exit()` | 새로운 프로세스 생성, 실행, 종료 등 |
| 파일 시스템 | `open()`, `read()`, `write()`, `close()` | 파일 열기, 읽기, 쓰기, 닫기 |
| 장치 제어 | `ioctl()`, `read()`, `write()` | 디바이스 접근 (예: 키보드, 디스크) |
| 정보 유지 | `getpid()`, `alarm()`, `sleep()` | PID 조회, 타이머 설정 등 |
| 통신 | `pipe()`, `shmget()`, `mmap()` | 프로세스 간 통신 (IPC) |

---

## 🔁 시스템 콜 동작 흐름

```
1. 사용자 프로그램에서 시스템 콜 호출 (예: read())

2. 소프트웨어 인터럽트 발생 (예: int 0x80, syscall 명령)

3. CPU가 커널 모드로 전환됨 (Dual Mode 전환)

4. 커널 내부에서 시스템 콜 핸들러 진입

5. 시스템 콜 번호로 요청 함수 구분 → 해당 커널 함수 실행

6. 결과 반환 → 유저 모드로 복귀 → 사용자 프로그램 재개
```

> ✅ 시스템 콜은 커널과 유저 모드 간 전환을 수반하므로 일반 함수 호출보다
     **오버헤드가 크다!**
> 

---

## ✨ 대표 예시 (Linux 기준)

```c
int fd = open("file.txt", O_RDONLY); // 파일 열기
read(fd, buffer, size);              // 파일에서 읽기
write(fd, buffer, size);             // 파일에 쓰기
close(fd);                           // 파일 닫기
```

→ 이 모든 건 내부적으로 시스템 콜!

---

## 💬 면접 대비 질문 포인트

| 질문 | 답변 요약 |
| --- | --- |
| 시스템 콜이란? | 커널 기능을 요청하는 인터페이스 |
| 왜 시스템 콜이 필요한가요? | 유저 모드에서는 커널 기능 직접 호출 불가 |
| 시스템 콜 호출 시 어떤 일이 일어나나요? | 커널 모드 전환 → 작업 수행 → 복귀 |
| 시스템 콜의 단점은? | 오버헤드 있음 (모드 전환 비용) |
| 자주 쓰이는 시스템 콜? | `read`, `write`, `open`, `fork`, `exec` 등 |

---

## 🔥 시스템 콜 vs 함수 호출

| 항목 | 시스템 콜 | 일반 함수 |
| --- | --- | --- |
| 실행 위치 | 커널 모드 | 사용자 모드 |
| 속도 | 느림 (오버헤드 有) | 빠름 |
| 목적 | OS 자원 접근 | 계산/기능 수행 |
| 예시 | `open()`, `fork()` | `printf()`, `strlen()` 등 |