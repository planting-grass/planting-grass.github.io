---
title: 2025-10-09
author: 조수아
date: 2025-10-09
category: TIL/조수아/2025/10
layout: post
---

# 오늘 배운 것

## 서블릿 JSP 라이프 사이클

### **1. 변환 및 컴파일**

- 최초 요청 시 JSP → Servlet 소스(.java) 변환
- 컴파일 후 `.class` 파일 생성

### **2. 객체 생성**

- WAS가 Servlet 객체를 메모리에 로드 및 생성

### **3. 초기화 (`_jspInit()`)**

- 최초 한 번 실행
- 리소스 초기화, DB 연결 준비 등 수행

### **4. 실행 (`_jspService()`)**

- 클라이언트 요청 시마다 실행
- JSP 코드 실행 및 HTML 응답 반환

### **5. 소멸 (`_jspDestroy()`)**

- WAS 종료, redeploy 시 실행
- DB 연결 해제, 자원 반환 등 정리 작업

## Cookie & Session

### Cookie

- 개념
    - 웹 서버에서 정보를 생성해서 클라이언트에 보관하는 데이터
- 특징
    - name을 제외한 property는 getter/setter로 접근 가능
    - name
        - 쿠키를 만들 때 전달하는 쿠키의 이름
        - 각각의 쿠키를 구별하는 유일 값
        - 동일한 이름의 쿠키는 기존 쿠키를 덮어 씀
        - 알파벳, 숫자, 하이픈, 언더스코어, 틸트, 점으로 구성
        - 공백 등 나머지 문자는 URL Encoder를 통해 인코딩 필요
    - value
        - 쿠키의 값으로 쿠키 생성시 전달하거나 setValue() 메서드를 통해 설정 가능
        - 작성 규칙은 name과 동일
        - 한글 사용 가능
    - path
        - 쿠키가 유효한 경로
        - path가 설정된 하위 경로에서만 쿠키 전송
        - parameter 기반이 아니라 경로 기반으로 url 설계 시 주의 필요
        - 경로 미 설정 시 → context root
            - 동일 도메인의 다른 애플리케이션까지 쿠키가 공유되어 보안 이슈 발생 할 수 있음
    - maxAge
        - 쿠키의 유효 기간
        - 양수 : 초단위로 해당 시간까지 쿠키가 존재하다가 자동 폐기
        - 음수 : 세션 쿠키로 브라우저 종료 등으로 세션 종료 시 폐기
        - 0 : 브라우저 도착하는 즉시 폐기 → 쿠키 삭제 시 활용
        - 크롬의 경우 최대 유효 기간 = 400일
    - secure
        - HTTPS에서만 전송 허용
    - httpOnly
        - JavaScript에서 접근 불가 설정
- 관련 객체 및 메소드
    - `jakarta.servlet.http.Cookie`
    - `Cookie cookie = new Cookie("user", "andy");`
    - `cookie.setMaxAge(60*1);`  → 1분
    - `response.addCookie(cookie);`
    - `Cookie[] cookies = request.getCookie();`

### Session

- 개념
    - 서버에 클라이언트의 상태 값을 저장
- 특징
    - 하나의 브라우저 당 하나의 세션 성립
    - 브라우저 닫으면 종료
    - JSESSIONID라는 이름의 쿠키가 있어야 동작
- 동작
    1. 최초 요청
    2. 세션 생성 및 저장 (Key : JSESSIONID)
    3. 최소 쿠키 전달 (JSESSIONID=XX)
    4. 브라우저 내 재요청
    5. 세션 확인 및 활용
- 관련 객체 및 메소드
    - Servlet에서 Session 객체 획득
        - request.getSession(): 현재의 세션을 반환 없으면 새로 생성
    - `Object getAttribute(String name)` : 세션 속성 가져오기
    - `void setAttribute(String name, Object value)` : 세션 속성 설정
    - `void removeAttribute(String name)` : 세션 속성 제거
    - `void invalidate()` : 세션 무효화, logout
    - `String getId()` : 세션 ID 가져오기
    - `long getCreationTime()` : 세션 생성 시간
    - `long getLastAccessedTime()` : 세션 마지막 접근 시간
    - `int getMaxInactiveInterval()` : 최대 세션 유효 기간
    - `void setMaxInactiveInterval(int interval)` : 최대 세션 유효기간 설정(초단위)
    - 세션은 lastAccessedTime 부터 + maxInactiveInterval까지 유효
        - 해당 값이 이미 만료된 시점이면 서버는 새로운 세션을 만들거나 null 반환
        - 해당 세션 객체는 GC 대상

## JSTL expression

- JSTL(JSP Standard Tag Library)
    - 자주 사용되는 기능들에 대해 정형화된 태그 제공
    - `<@ taglib prefix="c" uri="jakarta.tags.core"%>`
    - 태그
        - 웹 스코프에 el 변수 관리
            - `<c:set var="name" value="hong" scope="page"`
            - `<c:remove var="name" scope="page">`
                
                → 스코프 기본값 page
                
        - 조건문
            - `<c:if test="조건" [var="test_result"]`
                - var는 test_result의 test 결과를 el 변수로서 저장
            - `<c:choose>
            <c:when test="조건1"></c:when>
            <c:when test="조건1"></c:when>
            <c:otherwise></c:otherwise>
            </c:choose>`
        - 반복문
            - `<c:forEach var="변수명" items="대상컬렉션" varStatus="status"></c:forEach>`
            - `<c:forEach var="변수명" begin="1" end="10" [step="2"]></c:forEach>`
            - `<c:forEach var="변수명" items="대상컬렉션" begin="1" end="10" [step="2"]></c:forEach>`
- EL(Expression Language)
    - 출력을 위한 언어로 JSP의 expression 대체
    - 스코프에 저장된 attribute를 사용하기 편리
    - 기본 표현 법 : `${attribute_name}`
    - 스코프
        - pageScope → requestScope → sessionScope → applicationScope(순으로 검색하며 처음 발견된 값 활용)
        - 특정 스코프 사용시 명시적으로 스코프 지정 → `${sessionScope.sum}`
        - 값이 없을 경우 null이 아닌 공백으로 표시
    - js $와의 차이
        - el $ : 서버에서 attribute로 변경 후 client로 전송
        - js $ : 클라이언트에서 작동하므로 escape처리 필요
    - 내장 객체(${}안에 들어가는 값)
        - PageContext `pageContext`
        - Map `pageScope.attributeName`
        - Map `requestScope.attributeName`
        - Map `sessionScope.attributeName`
        - Map `applicationScope.attributeName`
        - Map `param.parameterName` → 단일
        - Map `paramValues.parameterName` → 복수
        - Map `cookie.cookieName`
        - Map `header` → 단일
        - Map `headerValues` → 복수
    - 객체 접근 시 주의
        - User-Agent 라는 이름이면 ${header[”User-Agent”] 이렇게 사용 `.`으로 바로 연결 불가
    - 연산자
        - 산술, 비교, 논리, 삼항 연산 가능
            - 문자열 자동 캐스팅 : “1” + “2” = 3
            - 나누기 : 정수간의 연산도 소수점의 결과 리턴
            - 비교 연산 : 문자 데이터 비교시 사전식 비교
        - empty 연산 있음
            - `${empty name}` , `${!empty name}`

## 클라이언트 요청방식

- `response.sendRedirect()`
    - URL을 웹 브라우저로 보내서 간접 호출
    - 최초 요청과 무관한 request와 response를 새로 생성
    - 클라이언트 입장에서는 2번의 호출 → 브라우저의 URL 변경
    - 다른 웹 애플리케이션의 자원 호출 가능
    - request레벨을 파라미터로 문자열만 전달 가능
        - queryString으로 redirect url에 추가
    - 필요 시 session attribute 사용 → session 관리 부담
    - / 는 container root
- `dispatcher.forward()`
    - 웹서버에서 직접 호출
    - 최초 발생한 request와 response 전달
    - 클라이언트 인장에서는 1번의 호출 → URL 변경없음
    - 동일 웹 애플리케이션의 자원만 호출
    - request parameter로 문자열, request attribute로 객체 전달가능
    - / 는 context root
- 에러 응답 코드
    - 404
        - front controller까진 진입 후 처리할 subcontroller 발견 실패
            - 처리 방식
                - action에서 404 페이지로 forward
                - response에서 404 에러발생하여 WAS가 기본 404 페이지로 처리
        - front controller까지 진입 실패
            - 서블릿까지 도달도 실패해서 WAS가 기본 404 페이지로 처리
    - 500
        - front controller에서 try~catch로 CheckedException 처리 후 직접 관련 페이지에 에러 메시지 전달
        - WAS로 예외 전파
            - Unchecked Exception : 언제나 전달
            - CheckedException : 보내고 싶다면 ServletException으로 wrapping하여 전달

## 서브 쿼리 조인

- GROUP BY에서는 서브 쿼리를 사용할 수 없다
- 구분 연산자 허용

## JDBC

- 특징
    - 표준화된 인터페이스 제공
    - 자바 애플리케이션과 DB와의 독립성 제공
- JDBC DB 연동 과정
    1. JDBC Driver Class 로딩(JDBC 4.0 이후 버전부터 생략 가능)
        - `Class.forName("com.mysql.cj.jdbc.Driver");`
    2. Connection 생성
        - `Connection conn = DriverManager.getConnection(url, user, password);`
            - java.sql.Connection
    3. Statement 생성
        - `Statement stmt = conn.createStatement();`
            - 가장 기본 statement
            - 생성시 실행할 SQL이 정해지지 않은상태
            - 매실행마다 실행할 SQL 전송
            - SQL Injection 공격에 취약
        - `PreparedStatement stmt = conn.prepareStatement(sql);`
            - 반복적인 SQL 작업을 최적화하여 통로 생성 시 실행할 SQL 미리 결정
            - 바뀌는 데이터 부분을 ?로 표기
                - `stmt.setInt(1, empNo);` 로 값 바인딩
                - SQL Injection에 대비 가능
        - `CallableStatement cstmt = conn.prepareCall("{CALL processReturn(?, ?)}");`
            - DB 내의 Stored Procedure를 호출하기 위한 SQL을 실행
            - 속도는 가장빠름
            - DBMS에 종속적
    4. SQL 실행
        1. select
            1. `excuteQuery();` 
            2. 리턴 : ResultSet
        2. insert, update, delete
            1. `excuteUpdate();` 
            2. 리턴 : int(처리된 행 수)
        3. 모든 sql
            1. `excute();` 
            2. 리턴 : boolean(실행 여부)
    5. 결과 집합 처리
        1. `ResultSet rs = psmt.executeQuery(sql);` 
        2. `while(rs.next())`
        3. `emp.setEmpNo(rs.getInt("empno"));`
    6. 자원 반납
        1. `rs.close();`
        2. `psmt.close();`
        3. `conn.close();`

## MVC 패턴

1. 사용자로부터 URL 기반 요청
2. Controller가 HTTP 요청 데이터를 검증하고 적절한 모델에 정보 처리 요청
3. Model이 비즈니스로직 처리 후 DB 연동후 결과 전달
4. Controller 결과를 request나 session에 담고 적절한 View 지정
5. View는 데이터 출력으로 응답을 위한 화면을 작성 후 HTML 기반 응답을 함

## 데이터베이스 뷰 객체 개념 존재 이유

- 테이블이나 또 다른 뷰를 기반으로 한 논리적인 가상의 테이블
- 데이터는 갖고있지 않지만 기반 테이블의 데이터를 보거나 변경할 수 있는 창의 역할을 함
- 복잡한 쿼리문을 뷰로 저장하여 반복 사용이 가능하여 복잡한 쿼리 단순화가능
- 뷰에 접근하는 사용자에게 미리 정의된 결과만 보여주어 보안이나 권한 제어가 가능
- 뷰에 포함되는 컬럼은 베이스 테이블에 영향을 주지 않고 다른 이름으로 참조 가능하여 변경이 용이함