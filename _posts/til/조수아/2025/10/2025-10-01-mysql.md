---
title: 2025-10-01
author: 조수아
date: 2025-10-01
category: TIL/조수아/2025/10
layout: post
---

# 오늘 배운 것

> 세미 조인(semijoin) 최적화 기법 중 FirstMatch와 Duplicate Weed-out 방식의 차이는 무엇이며, 어떤 상황에서 각각 유리한가요?
> 
> 
> **답변:**
> 
> FirstMatch는 상관 서브쿼리에서도 적용 가능하며, 첫 번째 매칭 레코드를 찾으면 즉시 검색을 중단하는 단축 실행 경로를 가지므로 빠른 응답이 필요한 경우 유리합니다. 반면 Duplicate Weed-out은 세미 조인 서브쿼리를 일반적인 INNER JOIN + GROUP BY로 바꿔 실행 후 중복을 제거하는 방식입니다. 따라서 서브쿼리를 조인으로 풀어 최적화할 수 있는 여지가 많고 다양한 경우에 활용되지만, GROUP BY나 집합 함수가 포함된 서브쿼리에는 사용할 수 없습니다.
> 

---

> 해시 조인(hash join)과 네스티드 루프 조인(nested loop join)의 실행 특성 차이는 무엇이며, 각각 어떤 서비스 환경에서 더 적합한가요?
> 
> 
> **답변:**
> 
> 해시 조인은 빌드 테이블을 해시 테이블로 만든 후 프로브 테이블을 탐색하는 구조라 첫 레코드를 찾는 데 시간이 오래 걸리지만, 이후 대량 처리 시 빠릅니다. 따라서 응답 속도보다 전체 처리량(스루풋)이 중요한 **분석 서비스**에 적합합니다. 네스티드 루프 조인은 첫 레코드 탐색이 빠르지만 전체 조인 완료까지 시간이 더 걸리므로, 빠른 응답 속도가 중요한 **웹 서비스**에 유리합니다. 결국 인덱스 유무와 조인 대상 데이터 크기에 따라 옵티마이저가 선택하게 됩니다.
> 

---

> Derived Merge 최적화(파생 테이블 머지)는 어떤 경우에 적용되며, 적용되지 못하는 대표적인 제약 조건은 무엇인가요?
> 
> 
> **답변:**
> 
> Derived Merge는 FROM 절의 파생 테이블을 외부 쿼리와 병합해 서브쿼리 부분을 제거함으로써 불필요한 임시 테이블 생성을 줄이고 최적화 여지를 넓히는 방법입니다. 다만 파생 테이블 내부에 집계 함수, 윈도우 함수, DISTINCT, GROUP BY/HAVING, LIMIT, UNION/UNION ALL, SELECT 절에 직접 포함된 서브쿼리, 사용자 변수 변경 등이 포함되면 병합할 수 없습니다. 따라서 단순 조회형 파생 테이블일수록 최적화가 잘 적용됩니다.

> 
- 추가 질문
    
    ### Q1. 세미 조인 최적화에서 **FirstMatch**와 **IN-to-EXISTS**의 차이는 무엇인가요?
    
    **A1.** IN-to-EXISTS는 단순히 서브쿼리 내부에서만 조건을 전파하지만, FirstMatch는 조인으로 풀어 처리하기 때문에 아우터 테이블까지 조건 전파가 가능합니다. 따라서 더 나은 실행 계획을 세울 수 있고, 일부만 최적화 적용도 가능합니다.
    
    ---
    
    ### Q2. **Table Pull-out** 최적화는 어떤 조건에서 사용 가능할까요?
    
    **A2.** 세미 조인 서브쿼리에 한정되며, 서브쿼리 결과가 **UNIQUE 인덱스나 PK 룩업으로 1건만 반환**되는 경우 가능합니다. 이 경우 서브쿼리를 아예 조인으로 바꿔서 실행해 성능을 높입니다.
    
    ---
    
    ### Q3. **Loose Index Scan**은 어떤 상황에서 적용되나요?
    
    **A3.** GROUP BY 최적화 시 단일 컬럼 인덱스나 복합 인덱스의 선행 컬럼이 WHERE 절에 있는 경우 사용할 수 있습니다. 모든 레코드를 읽지 않고 건너뛰며 그룹별 첫 번째 레코드만 스캔해 효율적입니다.
    
    ---
    
    ### Q4. **Materialization** 최적화의 특징은 무엇인가요?
    
    **A4.** 서브쿼리 전체를 **내부 임시 테이블로 구체화**한 뒤 조인에 활용합니다. IN(subquery) 형태에서 상관 서브쿼리가 아닐 때 적용되며, GROUP BY·집합 함수가 포함된 경우에도 사용할 수 있습니다.
    
    ---
    
    ### Q5. **Condition Fanout Filter**는 언제 효과적일까요?
    
    **A5.** 여러 테이블이 조인될 때, **레코드 건수가 적은 순서**로 조인하도록 도와 성능을 향상시킵니다. 단, 실행 계획 수립 오버헤드가 크기 때문에 쿼리 실행 빈도가 높은 경우는 신중히 사용해야 합니다.
    
    ---
    
    ### Q6. **Invisible Index**는 어떤 경우 활용할 수 있을까요?
    
    **A6.** 인덱스를 삭제하지 않고 옵티마이저가 사용하지 못하게 만들 수 있습니다. 인덱스 효율성 실험이나 마이그레이션 테스트 시 유용합니다.
    
    ---
    
    ### Q7. **Skip Scan** 최적화는 언제 가능할까요?
    
    **A7.** 인덱스 선행 컬럼이 조건절에 없더라도 후행 컬럼만으로 인덱스를 활용할 수 있습니다. 단, 선행 컬럼 값 종류가 적어야 효율적이고, 값이 너무 다양하면 성능이 오히려 나빠집니다.
    
    ---
    
    ### Q8. 해시 조인(Hash Join)과 네스티드 루프(Nested Loop)의 선택 기준은 무엇인가요?
    
    **A8.** 해시 조인은 첫 레코드 검색은 느리지만 전체 처리량이 많을 때 유리 → **분석 서비스**에 적합.
    
    네스티드 루프는 첫 레코드 검색이 빠르지만 전체는 느림 → **웹 서비스**에 적합.