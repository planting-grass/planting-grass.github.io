---
title: 2025-12-13
author: 조수아
date: 2025-12-13
category: TIL/조수아/2025/12
layout: post
---

# 오늘 배운 것

- **시스템 호출이 발생하면 CPU 내부에서는 어떤 일이 일어나며, 문맥 전환과 어떻게 다른가?**
    
    시스템 호출이 발생하면 응용프로그램은 소프트웨어 인터럽트를 일으켜 CPU를 사용자 모드에서 커널 모드로 전환시킨다. 이때 CPU는 현재 사용자 프로세스의 일부 레지스터 값과 프로그램 카운터를 저장하고, 커널 영역에 정의된 시스템 호출 처리 루틴으로 점프한다.
    
    이 과정은 커널 내부에서 수행되는 특권 명령을 실행하기 위한 모드 전환일 뿐, 일반적인 문맥 전환(Context Switch)과는 다르다. 문맥 전환은 프로세스 또는 스레드 자체가 변경될 때 수행되며, PCB 전체 상태(레지스터, 스케줄링 정보, 메모리 정보 등)까지 저장·복구해야 한다. 반면 시스템 호출은 같은 프로세스 내에서 모드만 전환되므로 저장해야 하는 정보가 훨씬 적고 오버헤드도 작다.
    
- **멀티스레드 환경에서 스택은 스레드마다 분리되는데, 이것이 필요한 이유와 힙 공유의 위험성은 무엇인가?**
    
    스택은 함수 호출 정보, 지역 변수, 리턴 주소 등 스레드의 독립된 실행 흐름을 유지하는 데 필요한 데이터를 저장한다. 실행 흐름이 서로 다른 스레드가 같은 스택을 공유하면 데이터 충돌이 발생하므로 스레드마다 별도의 스택이 제공된다.
    
    반면 힙은 프로세스 전체가 공유하는 영역으로, 여러 스레드가 동시에 접근할 수 있다. 이로 인해 동기화 없이 접근하면 race condition, memory corruption, double free 같은 문제가 발생할 수 있다. 따라서 멀티스레드 환경에서는 힙 접근에 대해 락, CAS 연산, 메모리 배리어 등 적절한 동기화 메커니즘을 반드시 사용해야 한다.
    
- **다단계 피드백 큐 스케줄링이 기아 상태를 완화할 수 있는 이유를 설명하고, SJF나 우선순위 스케줄링 대비 운영 비용이 높은 근본적인 이유를 설명하라.**
    
    다단계 피드백 큐(MFQ)는 프로세스가 CPU를 오래 사용하면 자동으로 우선순위가 낮은 큐로 이동시키고, 입출력 중심 프로세스처럼 빨리 종료되는 작업은 높은 우선순위 큐에 계속 유지한다. 또한 오랫동안 대기 중인 프로세스는 에이징을 통해 상위 큐로 끌어올리므로 우선순위 스케줄링의 대표적 문제인 기아 상태를 완화할 수 있다.
    
    하지만 MFQ는 각 큐마다 스케줄러를 별도로 관리하고, 프로세스 상태 변화에 따라 큐 이동을 지속적으로 모니터링해야 한다. 또한 타임슬라이스 관리, 에이징 조건 평가 등 정책 판단 비용이 SJF나 기본 우선순위 스케줄링보다 높다. 이 때문에 평균 실행 오버헤드가 증가하지만, 대신 실제 운영체제에서 더 높은 반응성과 공정성을 제공한다.
    
- **가상 메모리와 페이지 교체 알고리즘이 필요한 이유를 설명하고, LRU가 항상 최적이 아닌 이유를 구체적으로 설명하라.**
    
    가상 메모리는 실제 물리 메모리보다 더 큰 메모리 공간을 제공하기 위해 디스크를 보조 저장소로 활용하는 기술이다. 프로그램 전체를 올리지 않고 필요한 페이지만 적재하기 때문에 메모리 사용 효율이 높아지고 많은 프로세스를 동시에 실행할 수 있다.
    
    페이지 교체 알고리즘은 물리 메모리가 부족할 때 어떤 페이지를 내릴지 결정하는 방식이다. LRU는 최근 사용되지 않은 페이지를 교체하는 방식으로 실제 접근 패턴과 대체로 잘 맞지만, 항상 최적은 아니다.
    
    이유는 다음과 같다:
    
    1. 실제 LRU 구현은 정확한 시간 기반 추적이 어렵고 오버헤드가 크다.
    2. 특정 워크로드(순차 접근, 특정 패턴 반복)에서는 LRU가 꾸준히 잘못된 페이지를 교체해 스래싱을 유발할 수 있다.
    3. 최적 알고리즘(OPT)은 미래 접근을 알고 교체하지만 실제 시스템에서 미래 접근을 알 수 없기 때문에 LRU는 근사 알고리즘일 뿐이다.