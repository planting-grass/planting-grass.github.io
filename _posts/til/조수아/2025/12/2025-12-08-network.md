---
title: 2025-12-08
author: 조수아
date: 2025-12-08
category: TIL/조수아/2025/12
layout: post
---

# 오늘 배운 것

# 04-1 전송 계층 개요: IP의 한계와 포트

- 네트워크 계층의 IP 한계
    - 신뢰할 수 없는 통신
    - 비연결형 통신
- 전송 계층
    - 신뢰할 수 있는 통신
    - 연결형 통신
    - 포트 번호를 통한 응용 계층의 애플리케이션 프로세스들 식별

## 신뢰할 수 없는 통신과 비연결형 통신

- 신뢰할 수 없는 통신(=최선형 전달: 최선은 다해보겠지만, 전송 결과 보장 x)
    - 패킷이 수신지까지 제대로 전송되었다는 것을 보장하지 않음
        - 패킷의 데이터 손상, 중복 패킷 전송 확인 X
        - 재전송 X
        - 순서대로 패킷 도착 보장 X
- 비연결형 통신
    - 사전 연결 수립 작업 없이 수신지를 향해 패킷을 보내기만 함
- IP는 왜 신뢰할 수 없는 통신과 비연결형 통신을 할까? → 성능

## IP의 한계를 보완하는 전송 계층

### 전송 계층은 연결형 통신 가능

- TCP
    - 두 호스트가 정보를 주고 받기 전에 마치 가상의 회선을 설정하듯이 연결 수립
    - 송수신하는 동안에는 연결을 유지
    - 송수신 끝나면 연결 종료

### 전송 계층은 신뢰성 있는 통신 가능

- TCP
    - 재전송을 통한 오류 제어
    - 흐름제어
    - 혼잡 제어

## 응용 계층과의 연결 다리, 포트

### 포트의 정의

- 특정 애플리케이션을 식별할 수 있는 정보

### 포트의 분류

- 전송 계층에서 포트 번호를 통해 특정 애플리케이션 식별
- 포트 번호는 16비트 → 총 65536개
- 종류
    - 잘 알려진 포트 : 0 ~ 1023
        - 20, 21 : FTP
        - 22 : SSH
        - 23 : TELNET
        - 53 : DNS
        - 67, 68 : DHCP
        - 80 : HTTP
        - 443 : HTTPS
    - 등록된 포트 : 1024 ~ 49151 (흔히 사용되는 애플리케이션 프로토콜에 할당)
        - 1194 : OpenVPN
        - 1433 : Microsoft SQL Server 데이터베이스
        - 3306 : MySQL 데이터베이스
        - 6379 : Redis
        - 8080 : HTTP 대체
    - 동적포트(=사설포트,임시포트) : 49152 ~ 65535
        - 인터넷 할당 번호 관리 기관에 의해 할당된 애플리케이션 프로토콜이 없음
        - 특별히 관리되지 않는 포트 번호이기에 자유롭게 사용 가능

## 포트 기반 NAT

- NAT : IP 주소를 변환하는 기술
    - 네트워크 내부에서 사용되는 사설 IP주소 ↔ 네트워크 외부에서 사용되는 공인 IP 주소
    - NAT 변환 테이블 이용

### NAT 변환 테이블

- 변환의 대상이 되는 IP 주소 쌍이 명시
- 사설 IP 주소 하나당 공인 IP 주소 하나가 대응
    - 이렇게 되면 네트워크 내부에서 사용되는 사설 IP 주소 만큼 공인 IP 주소가 필요하다는 문제 발생
    - 포트를 활용하여 해결

### NAPT(Network Address Port Translation = APT (Address Port Translation))

- 포트 기반의 NAT
- 하나의 공인 IP 주소를 여러 사설 IP 주소가 공유할 수 있도록 하는 NAT의 일종
- NAT 테이블에 변환할 IP 주소쌍과 더불어 포트번호도 함께 기록하고 변환
- 공인 IP 주소 수 부족 문제 개선

<aside>
💡

### 포트 포워딩

- 네트워크 내 특정 호스트에 IP 주소와 포트 번호를 미리 할당하고, 해당 IP주소:포트번호로써 해당 호스트에게 패킷을 전달
- 처음 패킷을 보내는 네트워크 외부 호스트 입장에서는 어떤 IP 주소 및 포트를 수신지 주소로 삼을지 결정하기 어려움
    - 이때 활용
- 외부에서 내부의 서버에 접속할 수 있도록 접속 정보를 공개하기 위해 자주 사용
</aside>

<aside>
💡

### ICMP

- IP의 신뢰할 수 없는 전송 특성과 비연결형 전송특성 보완하기 위한 네트워크 계층의 프로토콜
- IP 패킷의 전송 과정에 대한 피드백 메시지를 얻기 위해 사용하는 프로토콜
- 종류
    - 전송 과정에서 발생한 문제상황에 대한 오류보고
    - 네트워크에 대한 진단 정보
- 메시지 구성
    - 타입 : ICMP 메시지의 유형 번호
        
        
        | 타입이름 | 코드 번호 | 코드설명 |
        | --- | --- | --- |
        | 3 : 수신지 도달 불가 | 0 | 네트워크 도달 불가 |
        |  | 1 | 호스트 도달 불가 |
        |  | 2 | 프로토콜 도달 불가 |
        |  | 3 | 포트 도달 불가 |
        |  | 4 | 단편화 필요한데 DF=1이라 단편화 불가 |
        | 11 : 시간 초과 | 0 | TTL 만료 |
        | 8: 에코 요청 | 0 | 에코 요청 |
        | 0 : 에코 응답 | 0 | 에코 요청에대한 응답 |
        | 9 : 라우터 광고 | 0 | 라우터 광고 : 라우터가 호스트에게 자신을 알림 |
    - 코드 : 구체적인 메시지 내용
    
</aside>

# 04-2 TCP와 UDP

- TCP : 신뢰할 수 있는 통신을 위한 연결형 프로토콜
- UDP : TCP 보다 신뢰성은 떨어지지만 비교적 빠른 통신이 가능한 비 연결형 프로토콜

## TCP 통신 단계와 세그먼트 구조

- 통신 단계
    1. 연결 수립
    2. 데이터 송수신(재전송을 통한 오류 제어, 흐름 제어, 혼잡 제어)
    3. 연결 종료
- MSS(Maximum Segment Size) : TCP로 전송할 수 있는 최대 페이로드 크기
    - TCP 헤더 크기는 제외
- TCP 헤더 구조
    - 송신지 포트 / 수신지 포트
    - 순서 번호 : 송수신 되는 세그먼트의 올바른 순서를 보장하기 위해 세그먼트 데이터의 첫 바이트에 부여되는 번호
    - 확인 응답 번호 : 상대 호스트가 보낸 세그먼트에 대한 응답
        - 다음으로 수신하기를 기대하는 순서번호 명시
    - 제어 비트 : 세그먼트에 대한 부가 정보
    - 윈도우 : 수신 윈도우 크기
        - 한번에 수신하고자 하는 데이터의 양

### 제어 비트

- 8비트
- ACK : 세그먼트의 승인을 나타내기 위한 비트
- SYN : 연결을 수립하기 위한 비트
- FIN : 연결을 종료하기 위한 비트

### 순서번호와 확인응답 번호

- 신뢰성 보장하기 위한 필드
- 순서 번호
    - 세그먼트의 올바른 송수신 순서를 보장
    - 세그먼트 데이터의 첫 바이트에 부여되는 번호
    - 초기 순서 번호(ISN) : 처음 통신을 위해 연결을 수립할 때의 무작위 순서 번호
        - 이후 세그먼트의 순서번호는 초기 순서번호 + 송신 바이트 수
- 확인 응답 번호
    - 수신자가 다음으로 응다바 받기를 기대하는 순서
    - 수신한 순서번호 + 1

## TCP 연결 수립과 종료

### 연결 수립 : 3-way handshake

- 과정
    - SYN
    - SYN+ACK
    - ACK
- 액티브 오픈 : 처음 연결을 시작하는 호스트
- 패시브 오픈 : 연결 요청을 받고 요청에 따라 연결을 수립해주는 호스트

### 연결 종료

- 과정
    - FIN(A → B)
    - ACK(B → A)
    - FIN(B → A)
    - ACK(A → B)
- 액티브 클로즈 : 먼저 연결 종료하려는 호스트
- 패시브 클로즈 : 연결 종료 요청을 받아들이는 호스트

## TCP 상태

- TCP는 상태를 유지하고 활용한다는 점에서 스테이트풀 프로토콜

### 연결이 수립되지 않은 상태

- CLOSED : 아무런 연결 없음
- LISTEN : 일종의 연결 대기 상태
    - 패시브 오픈 호스트의 상태

### 연결 수립 상태

- SYN-SENT : 액티브 오픈 호스트가 SYN 전송
- SYN-RECEIVED : 패시브 오픈 호스트가 SYN 받고 SYN+ACK 전송
- ESTABLISHED : 액티브 오픈 호스트가 SYN+ACK 받고 ACK 전송, 패시브 오픈 호스트가 ACK 받음

### 연결 종료 상태

- FIN-WAIT-1 : 액티브 클로즈 호스트가 FIN 전송
- CLOSE_WAIT : 패시브 클로즈 호스트가 FIN 받고 ACK 전송
- FIN-WAIT-2 : 액티브 클로즈 호스트가 ACK 받음
- LAST- ACK : 패시브 클로즈 호스트가 FIN 전송
- TIME-WAIT : 액티브 클로즈 호스트가 FIN 받고 ACK 전송
    - 필요 이유
        - 마지막 ACK 유실시 재전송하기 위해 대기
        - 한 연결 종료 후 다른 연결 수립하는 과정 사이의 대기시간 없으면 서로 다른 연결 패킷들이 혼란
- CLOSED : 액티브 클로즈 호스트가 TIME-WAIT 시간동안 대기 후 전환, 패시브 클로즈 호스트가 ACK 받음
- CLOSING : 동시에 연결 종료하려 할 때
    - 서로 FIN 보내고 각자 그에 대한 ACK 보냈는데 자신의 FIN에 대한 ACK 받지 못했을 때 전환 됨
    - ACK를 수신하면 TIME-WAIT 전환 후 CLOSED

## UDP 데이터그램

- 비연결형 통신을 수행하는 신뢰할 수 없는 프로토콜
- 스테이트리스 프로토콜
- 구조
    - 송신지포트/수신지포트
    - 길이 : 헤더를 포함한 UDP 데이터그램의 바이트
    - 체크섬 : 오류 발생 검사
        - 문제가 있으면 폐기
- TCP에 비해 적은 오버헤드로 패킷을 빠르게 처리
- 패킷이 손실되거나 패킷의 순서가 바뀔 수 있음

# 04-3 TCP의 오류/흐름/혼잡 제어

## 오류 제어 : 재전송 기법

### 오류 검출과 재전송

- TCP가 세그먼트에 문제가 있음을 감지하는 상황
    - 중복된 ACK 세그먼트를 수신했을 때
    - 타임아웃이 발생할 때
        - 세그먼트를 전송할 때마다 재전송 타이머 시작
        - 이 타이머의 카운트 다운이 끝난 상황, 즉 타임아웃이 발생할 때까지 ACK를 받지 못하면 문제 감지

### ARQ: 재전송 기법

- ARQ(Automatic Repaeat Request)(자동 재전송 요구)
    - 수신 호스트의 답변(ACK)과 타임아웃 발생을 토대로 문제를 진단하고, 문제가 생긴 메시지를 재전송함으로써 신뢰성 확보 방식
    - 방식
        - Stop-and-Wait ARQ
            - 제대로 전달했음을 확인하기 전까지 새로운 메시지를 보내지 않는 방식
            - 장점 : 단순, 높은 신뢰성
            - 단점 : 네트워크 이용 효율 낮아짐 → 성능 저하
        - Go-Back-N
            - 파이프라이닝 : 연속해서 메시지를 전송할 수 있는 기능
            - 파이프라이닝 방식을 활용해 여러 세그먼트를 전송하고, 도중에 잘못 전송된 세그먼트가 발생할 경우 해당 세그먼트부터 전부 다시 전송
            - GO-Back-N ARQ의 ACK 세그먼트 = 누적 확인 응답
            - 단점 : 한 세그먼트에만 문제가 발생해도 그 후의 모든 세그먼트 다시 재전송
        - Selective Repeat ARQ
            - 선택적으로 재전송
            - 수신 호스트 측에서 제대로 전송받은 각각의 패킷들에 대해 ACK 세그먼트를 보내는 방식
            - 송신 호스트는 올바르게 수신받지 못한 ACK 세그먼트가 있는지 검사하고, 만일 응답받지 못한 세그먼트가 존재한다면 해당 세그먼트를 재전송
            - Selective Repeat ARQ의 ACK 세그먼트 = 개별 확인 응답
- 오늘날 대부분 호스트 TCP 통신에서 Selective Repeat ARQ 지원
    - 연결 수립시 가능한지 확인하고 사용하지 않으면 Go-Back-N ARQ 방식으로 동작

<aside>
💡

### 빠른 재전송

- 재전송 타이머가 만료되기 전이라도 세번의 동일한 ACK 세그먼트가 수신되며ㅕㄴ 해당 세그먼트를 곧바로 재전송
- 시간 낭비를 줄이며 빠르게 손실된 세그먼트를 재전송함으로써 성능을 높
</aside>

## 흐름 제어: 슬라이딩 윈도우

- 흐름제어를 해야하는 이유
    - 호스트가 한 번에 받아서 처리할 수 있는 세그먼트의 양에는 한계가 있음
- 수신 버퍼 : 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시로 저장되는 공간
- 버퍼 오버플로우 : 저장 가능한 공간보다 더 많은 데이터를 저장할 수는 없는 법
- TCP 흐름 제어
    - 버퍼 오버플로우를 방지하고자 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 유지하는
- 슬라이딩 윈도우
    - 윈도우 : 송신 호스트가 파이프라이닝할 수 있는 최대량을 의미
        - 윈도우 크기 만큼 확인 응답을 받지 않고도 한 번에 전송 가능
    - 송신측 윈도우는 수신 호스트가 알려주는 수신 측 윈도우를 토대로 알 수 있는 정보
    - 수신 호스트는 TCP 헤더(윈도우 필드)를 통해 송신 호스트에게 자신이 받아들이고자 하는 데이터의 양을 알림
    - 송신호스트는 이 정보를 바탕으로 수신 호스트의 처리 속도와 발맞춰 균일한 속도로 세그먼트 전송
    - 수신 호스트가 첫 번째 세그먼트를 올바르게 수신하면 수신 윈도우 오른쪽으로 한 칸 이동

## 혼잡 제어

- 혼잡 : 많은 트래픽으로 인해 패킷의 처리 속도가 늦어지거나 유실될 우려가 있는 네트워크 상황
    - 예
        - 모든 호스트가 라우터에게 전송 가능한 최대의 양으로 세그먼트 전송
        - 라우터에 과부하 생겨 모든 정보를 한 번에 처리 불가
        - 호스트들은 오류 검출하여 재전송
        - 그럴수록 라우터는 더 많은 세그먼트를 받게 되어 혼잡 현상 악화
- 혼잡 제어의 주체 : 송신 호스트
    - 송신호스트가 네트워크 혼잡도를 판단하고 혼잡한 정도에 맞춰 유동적으로 전송량을 조절하며 전송
- 혼잡 윈도우 : 혼잡 없이 전송할 수 있을 법한 데이터 양
    - 이 혼잡 윈도우는 송신 호스트가 계산해야함
- 혼잡 제어 알고리즘 : 혼잡 윈도우 크기 결정 알고리즘
    - AIMD(Additive Increas/Multiplicative Decrease)
        - 합으로 증가, 곱으로 감소
        - 혼잡이 감지되지 안으면 혼잡 윈도우를 RTT(Round Trip Time) 마다 1씩 선형적으로 증가
        - 혼잡이 감지되면 혼잡 윈도우를 절반으로 떨어뜨리는 동작 반복
    - 느린 시작
        - 혼잡 윈도우를 1부터 시작해 문제없이 수신된 ACK 세그먼트 하나당 1씩 증가
        - 결과적으로 혼잡 윈도우는 RTT마다 2배씩 지수적으로 증가
        - 장점
            - AIMD는 처음 연결이 수립된 뒤 혼잡 윈도우 크기가 증가되는 속도가 느려 초기 전송속도가 확보되지 않음
                - 느린 시작은 지수적인 증가를 활요해 초기 전속 속도를 어느정도 빠르게 확보
        - 혼잡 윈도우가 느린 시작 임계치 이상
            - 혼잡 윈도우 값을 1로, 느린 시작 임계치를 혼잡이 감지되었을 시점의 혼잡 윈도우 값의 절반으로 초기화 한뒤 느린시작 재개
        - 타임아웃 발생
            - 느린 시작 종료, 혼잡 윈도우를 절반으로 초기화한 뒤 혼잡 회피 수행
        - 세번의 중복된 ACK 세그먼트 발생 혼잡 감지
            - 빠른 재전송 후 빠른 회복 수행
    - 혼잡 회피
        - RTT마다 혼잡 윈도우 1MSS(Maximum Segment Size)씩 증가
        - 느린 시작 임계치를 넘어선 시점부터 혼잡이 발생할 우려가 있으니 조심해서(선형적으로) 혼잡 윈도우 증
        - 혼잡 회피 도중 타임아웃 발생
            - 혼잡 윈도우 1, 느린 시작 임계치는 혼잡이 감지된 시점의 혼잡 윈도우 값의 절반으로 초기화 한뒤 다시 느린 시작 수행
        - 혼잡 회피 도중 세번의 중복 ACK 세그먼트 발생
            - 혼잡 윈도우 값과 느린 시작 임계치를 대략 절반으로 떨어뜨린 뒤 빠른 회복 알고리즘 수행
                - 이때 타임아웃이 발생한 세그먼트나 세번의 중복 ACK 세그먼트가 발생한 세그먼트는 재전송
    - 빠른 회복 알고리즘
        - 세번의 중복 ACK 세그먼트를 수신하면 빠른 재전송 + 빠른 회복 알고리즘
        - 빠른 회복 : 세번의 중복 ACK 세그먼트를 수신했을 때 느린 시작은 건너뛰고 혼잡 회피를 수행
        - 빠른 전송률을 회복하기 위한 알고리즘
        - 빠른 회복 도중 타임아웃
            - 혼잡 윈도우 1, 느린 시작 임계치는 혼잡이 감지된 시점의 절반으로 떨어뜨린 후 다시 느린 시작 수행

<aside>
💡

### ECN: 명시적 혼잡 알림

- 네트워크 중간 장치(주로 라우터)의 도움으로 혼잡을 회피
- 선택적인 기능
- TCP/IP 프로토콜로 정보를 주고받을 때 IP 헤어돠 TCP 헤더에 ECN 관련 필드 추가
- 과정
    - A → B메시지 전송을 위해 라우터에게 메시지 보냄
    - 라우터 입장에서 네트워크가 혼잡해질 것 같다고 판달할 경우 IP 헤더의 ECN 비트들을 설정한채 B에 전달 IPv4 ECN = 11 → 혼잡 감지
    - B가 전달받은 IP 패킷 내에 혼잡 표시가 있다면, TCP ACK 세그먼트 내 ECE 비트 세팅을 통해 A에게 네트워크 혼잡함을 알려줌
    - A가 받은 세그먼트에서 ECE 비트가 설정되어 있을 경우, 송신 호스트는 CWR 비트를 세팅 후 혼잡 윈도우 반으로 줄임
- 장점
    - 타임아웃, 중복된 ACK 세그먼트 수신과 같이 문제 발생전에 더빠르게 혼잡 제어 수행
    - 일반적으로 세 번의 중복된 ACK 세그먼트 수신 이후나 타임아웃 발생 후에 혼잡 제어하는 방식에 비해 더 빠름
</aside>