---
title: 2025-12-20
author: 조수아
date: 2025-12-20
category: TIL/조수아/2025/12
layout: post
---

# 오늘 배운 것

# 14-1 연속 메모리 할당

## 스와핑

- 스와핑
    - 입출력 작업의 요구로 대기 상태가 된 프로세스라던지, 오랫동안 사용되지 않은 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식
- 스왑 영역
    - 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
- 스왑 아웃
    - 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- 스왑 인
    - 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것
- 스왑 아웃 후 다시 스왑 인이 되면 이전과 다른 물리 주소에 적재될 수 있음
- 스와핑을 사용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있음

## 메모리 할당

### 최초 적합

- 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치
- 장점
    - 검색 최소화 → 빠른 할당 가능

### 최적 적합

- 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식

### 최악 적합

- 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치

## 외부 단편화

- 연속 메모리 할당은 외부 단편화라는 문제를 내포함
- 외부 단편화
    - 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상
    - 해결 방법
        - 메모리 압축
            - 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기 저기 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법
            - 단점
                - 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 함
                - 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드 야기
                - 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법 결정하기 어려움
        - 페이징 기법

# 14-2 페이징을 통한 가상 메모리 관리

- 가상 메모리
    - 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
    - 기법
        - 페이징
        - 세그멘테이션

## 페이징이란

- 페이징
    - 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법
    - 페이징 시스템에서의 스왑 아웃, 스왑 인을 페이지 아웃, 페이지 인이라고 부름
        - 페이징 단위로 스와핑이 이루어짐
        - 이를 통해 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요 없이 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조 기억 장치에 남겨둘 수 있음

## 페이지 테이블

- 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 다음에 실행할 명령어 위치를 찾기 어려워짐
- 페이징 시스템은 프로세스가 물리 주소에 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 페이지 테이블을 이용
- 페이지 테이블
    - 어떤 페이지가 어떤 프레임에 할당되었는지를 알려줌
    - 프로세스마다 각자의 프로세스 테이블이 있음
    - 각 프로세스의 페이지 테이블들은 메모리에 적재
    - CPU내의 페이지 테이블 베이스 레지스터(PTBR)는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있음
- 페이지 테이블을 메모리에 두면 문제
    - 메모리 접근 시간이 두배로 늘어남
        - 메모리에 있는 페이지 테이블을 보기 위해 한 번
        - 그렇게 알게 된 프레임에 접근하기 위해 한 번
        - 2번의 메모리 접근 필요
    - 해결 방법
        - TLB(Translation Lookaside Buffer)
            - CPU 곁(일반적으로 MMU 내에)에 있는 페이지 테이블의 캐시 메모리
            - 페이지 테이블의 일부 내용을 저장
            - 참조 지역성에 근거해 최근에 사용된 페이지 위주로 가져와 저장
            - TLB 히트 : CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우
            - TLB 미스 : 없을 경우

<aside>
💡

### 내부 단편화

- 페이징은 내부단편화라는 문제를 야기할 수 있음
- 모든 프로세스 크기가 페이지의 배수가 아니라서 페이지에 빈공간으로 인해 메모리 낭비가 일어나는 것
- 내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생
- 페이지 크기가 너무 작으면 내부 단편화의 크기가 줄어들 수 있지만 그만큼 페이지 테이블의 크기도 커지기 때문에 페이지 테이블이 차지하는 공간이 낭비됨
- 그렇다고 크게 설정하면 내부 단편화 크기가 커져 낭비 될 수 있으므로 적절한 페이지의 크기를 조정하는 것이 중요
</aside>

## 페이징에서의 주소 변환

- 특정 주소에 접근하기 위해 알아야할 정보
    - 어떤 페이지 혹은 프레임에 접근하고 싶은지
    - 접근하려는 주소가 그 페이지 혹은 프레임으로 부터 얼마나 떨어져 있는지
- 따라서 페이징 시스템에서는 모든 논리 주소가 페이지 번호와 변위로 이루어져 있음
    - 페이지 번호 : 접근하고자 하는 페이지 번호
        - 페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지 알 수 있음
    - 변위 : 접근하려는 주소가 프레임의 시작 번지로부터 얼마큼 떨어져 있는지 알기 위한 정보
    - <페이지 번호, 변위> — 페이지 테이블—> <프레임 번호, 변위>

## 페이지 테이블 엔트리

- 페이지 테이블의 각각의 행
- 페이지 테이블 엔트리에는 페이지 번호, 프레임 번호, 유효 비트, 보호 비트, 참조 비트, 수정 비트 등이 담김
    - 유효 비트 : 현재 해당 페이지에 접근 가능한지 여부
        - 페이지가 메모리에 적재 : 1
        - 페이지가 메모리에 적재 X : 0
        - 유효 비트가 0인 페이지에 접근하려고 하면 → 페이지 폴트라는 예외 발생
        - 페이지 폴트 처리 과정
            1. CPU는 기존의 작업 내역을 백업
            2. 페이지 폴트 처리 루틴을 실행
            3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해 줌
            4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근할 수 있게 됨
    - 보호 비트 : 페이지 보호 기능을 위해 존재
        - 0 : 읽기만 가능
        - 1 : 읽고 쓰기가 모두 가능
        - 더 복잡하게 (rwx) 읽기, 쓰기, 실행의 조합으로 나타낼 수 있음
    - 참조 비트 : CPU가 이 페이지에 접근한 적이 있는지 여부를 나타냄
        - 1 : 적재 이후 CPU가 읽거나 쓴 페이지
        - 0 : 적재 이후 한 번도 읽거나 쓴 적이 없는 페이지
    - 수정 비트 : 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부(더티 비트)
        - 1 : 변경된 적이 있는 페이지
        - 0 : 변경된 적이 없는 페이지(접근 X or 읽기만)
        - 페이지 아웃될 때 보조 기억 장치에 쓰기 작업을 해야 하는지 여부 판단을 위해 존재

<aside>
💡

### 페이징의 이점 - 쓰기 시 복사

- 페이징은 프로세스 간에 페이지를 공유할 수 있음
- 예 : 쓰기 시 복사
    - 부모 프로세스와 동일한 자식 프로세스가 생성
    - 자식 프로세스로 하여금 부모 프로세스와 동일한 프레임을 가리킴
    - 이를 통해 부모 프로세스의 메모리 공간을 복사하지 않고도 동일한 코드 및 데이터 영역을 가리킬 수 있음
    - 부모 혹은 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면 그 순간 해당 페이지가 별도의 공간으로 복제
    - 이를 통해 프로세스 생성시간을 중리고 메모리 공간 절약 가능
</aside>

<aside>
💡

### 계층적 페이징

- 페이지 테이블의 크기가 생각보다 작지 않음
- 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비
- 해결 방법 → 계층적 페이징(다단계 페이지 테이블)
    - 페이지 테이블을 페이징 하여 여러 단계의 페이지를 두는 방식
    - 프로세스의 페이지 테이블을 여러 개의 페이지로 자르고
    - 바깥쪽에 페이지 테이블 하나 더 두어 잘리 페이지 테이블의 페이지들을 가리키게 하는 방식
    - 이 환경에서 논리 주소는 <바깥 페이지 번호, 안쪽 페이지 번호, 변위> 로 구성
    - 주소 변환 과정
        - 바깥 페이지 번호를 통해 페이지 테이블의 페이지 찾기
        - 페이지 테이블의 페이지를 통해 프레임 번호를 찾고 변위를 더함으로서 물리 주소 얻기
- 계층의 수는 여러개가 될 수 있음
- 계층이 늘어날 수록 페이지 폴트가 발생했을 경우 메모리 참조 횟수가 많아지므로 계층이 많다고 해서 반드시 좋다고 볼 수 없음
</aside>

# 14-3 페이지 교체와 프레임 할당

## 요구 페이징

- 요구 페이징
    - 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법
    - 과정
        1. CPU가 특정 페이지에 접근하는 명령어를 실행
        2. 유효 비트가 1일 경우 CPU는 페이지가 적재된 프레임에 접근
        3. 유효 비트가 0일 경우 페이지 폴트 발생
        4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정
        5. 다시 1을 수행
    - 순수 요구 페이징
        - 아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행
        - 첫 명령어를 실행하는 순간부터 페이지 폴트가 계속 발생하고 어느정도 실행에 필요한 페이지가 어느 정도 적재된 이후부터는 페이지 폴트 발생 빈도가 떨어짐
    - 요구 페이징 기법으로 페이지들을 적재하다 보면 언젠가 메모리가 가득 차게 됨
        - 어떤 페이지를 내보낼 지 결정하는 방법이 필요 → 페이징 교체 알고리즘

## 페이지 교체 알고리즘

- 페이지 폴트를 가장 적게 일으키는 알고리즘을 좋은 알고리즘으로 평가
    - 페이지 참조열을 통해 페이지 폴트의 발생 횟수를 고려해야 함

### FIFO 페이지 교체 알고리즘

- 가장 먼저 올라온 페이지부터 내쫓는 방식
- 장점
    - 아이디어와 구현이 간단
- 단점
    - 프로그램 실행 내내 사용될 내용인데 단순히 먼저 적재되었다고 해서 내쫓으면 페이지 폴트 자주 발생
- 2차 기회 페이지 교체 알고리즘 → FIFO 페이지 교체 알고리즘의 부작용을 어느정도 개선한 알고리즘
    - 가장 오래 머물렀던 페이지를 내보낼 페이지로 선별
    - 만약 참조 비트가 1이면 당장 내쫓지 않고 참조비트를 0으로 만든 뒤 현재 시간을 적재 시간으로 설정

### 최적 페이지 교체 알고리즘

- CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘
- 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
- 장점
    - 페이지 폴트 발생 빈도가 가장 낮음
- 단점
    - 구현이 어려움 → 앞으로 오랫동안 사용되지 않을 페이지를 예측하는 것은 어려움
    - 따라서 이론상으로 성능 평가하기 위한 목적으로 사용

### LRU 페이지 교체 알고리즘

- 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘
- 최근에 사용됮 않은 페이지는 앞으로도 사용되지 않을 것이라는 아이디어를 토대로 생성된 알고리즘

## 스래싱과 프레임 할당

- 페이지 폴트가 발생하는 이유는 단순히 나쁜 교체 알고리즘 때문만이 아님
- 프로세스가 사용할 수 있는 프레임 수가 적어도 자주 발생
- 스래싱
    - 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제
    - 지나치게 빈번한 페이지 교체로 인해 CPU 이용률이 낮아지는 문제를 뜻함
- 멀티프로그래밍의 정도
    - 메모리에서 동시 실행되는 프로세스의 수
- 멀티프로그래밍의 정도를 늘린다고 해서 CPU 이용률이 그에 비례해서 증가하는 것이 아님
    - 어느 정도 증가하다가 필요 이상으로 늘리면 각 프로세스들이 사용할 수 있는 프로세스가 적어지기 때문에 페이지 폴트가 지나치게 빈번히 발생하여 CPU 이용률이 떨어져 전체적인 성능 저해
    - 각 프로세스들이 무리 없이 실행하기 위한 최소한의 프레임 수를 파악하고 프로세스들에 적절한 수만큼 프레임을 할당해 줄 수 있어야 함
- 프레임 할당 방식
    - 정적 할당 방식 : 프로세스의 실행 과정을 고려하지 않고 단순히 프로세스의 크기와 물리 메모리의 크기만을 고려
        - 균등 할당 : 모든 프로세스에 균등하게 프레임을 제공
            - 장점 : 간단
            - 단점 : 실행되는 프로세스의 크기가 각기 다른데 동일한 개수를 제공하는 것은 비합리적
        - 비례 할당 : 프로세스의 크기가 크면 프레임을 많이 할당하고 프로세스 크기가 작으면 프레임을 적게 나눠 주는 방식
            - 장점 : 균등 할당보다는 효율적
            - 단점 : 막상 실행 했을 때 프로세스 크기와 비례하게 프레임이 필요하지 않을 수 있음
    - 동적 할당 방식 : 프로세스의 실행을 보고 할당할 프레임 수를 결정
        - 작업 집합 모델 사용하는 방식
            - 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교체를 방지
            - 작업 집합 : 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합
                - 구하는 방식
                    - 프로세스가 참조한 페이지와 일정 시간 간격이 필요
                    - 일정 시간 간격 동안 프로세스가 참조한 페이지의 수 구하기
            - 작업 집합의 크기만큼만 프레임을 할당
        - 페이지 폴트 빈도를 사용하는 방식
            - 아이디어
                - 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있음
                - 페이지 폴트율이 너무 낮으면 그 프로세스가 너무 많은 프레임을 갖고 있음
            - 페이지 폴트율에 상한성과 하한선을 정하고, 이 범위안에서만 프레임을 할당