---
title: Java
author: 김희원
date: 2026-01-26
category: TIL/김희원/2026/01
layout: post
---

# 자바 버전의 차이 
| **구분** | **Java 11 (Legacy Modern)** | **Java 17 (Current Standard)** | **Java 25 (Next-Gen Performance)** |
| --- | --- | --- | --- |
| **핵심 키워드** | **안정화 & 모듈화** | **생산성 & 데이터 모델링** | **동시성(Concurrency) 혁명** |
| **주요 기능** | `var`, HTTP Client, G1GC 개선 | `record`, `sealed class`, 텍스트 블록 | **Virtual Threads**, 구조화된 동시성 |
| **스프링 호환** | Spring Boot 2.x (End of Life) | **Spring Boot 3.x의 최소 요구사항** | Spring Boot 4.x / Modern Native |
| **면접 포인트** | 함수형 스타일 도입, GC 튜닝 | 보일러플레이트 제거, 타입 안정성 | **블로킹 I/O 처리 방식의 변화** |


## 자바 11
- 자바 8 이후 가장 많이 사용된 LTS 버전. 현재로선 최소한의 레거시 기준선
- 로컬 변수 문법 개선 `var`: 타입 추론으로 코드의 간결성 높임
- 표준 HTTP Client API: 기존의 HttpURLConnection 한계를 넘어서 Non Blocking 및 비동기 처리가 가능하다. 외부 API 통신이 잦은 환경에 중요함
  - HTTPURLConnection의 한계: 요청을 보내고 응답이 올 때까지 해당 스레드가 아무것도 못하고 Block함
    - 이러다가 외부 API 서버가 느려지면 내 서버의 스레드 풀이 고갈돼서 전체 장애로 이어짐 "스레드 지옥" 
  - Non Blocking (HttpClient): 스레드가 응답을 안 기다리고 다른 일을 처리할 수 있게 됨 
- G1GC가 기본 GC로 정착: 대용량 힙 메모리 관리에 최적화되어있음

### Blocking과 Non-Blocking 
- 호출된 함수가 제어권을 바로 돌려주는가?
- Blocking: A 함수가 B 함수를 호출하면 B가 끝날 때까지 A는 멈춰 있음 
- Non-Blocking: A함수가 B함수를 호출하면 B는 실행을 시작함과 동시에 제어권을 A에게 돌려줘서 A는 멈추지 않고 자기 할 일을 반복함. 

### Synchronous vs Asynchronous 
- 작업 완료를 누가 신경쓰는지?
- Sync: A가 B에게 일을 시키고, B가 끝났는지 A가 계속 확인하거나 기다려서 결과를 받습니다.
- Async: A가 B에게 일을 시키고 콜백(Callback)을 전달합니다. B는 작업이 끝나면 알아서 콜백을 실행해 결과를 알려줍니다. A는 신경 끄고 있습니다.

### G1GC Garbage First Garbage Collector 
대용량 메모리 환경에서의 예측 가능한 성능 목표 
- 기본 GC: Heap 영역을 물리적 단위가 아닌 논리적 단위로 관리함. 따라서 survivor 영역과 old 영역이 딱 구분지어져 있지 않음
- 따라서 청소할 때 전체 heap을 뒤지지 않고 쓰레기가 가장 많은 Region을 먼저 청소함
- 이렇게 되면 개발자가 "GC 멈춤 시간을 200ms 안으로 맞춰줘"라고 설정하면 G1GC는 이 목표 시간을 지키기 위해 청소할 리전의 개수를 알아서 조절함
- 이는 응답 속도가 중요한 실시간 서비스나 대규모 트래픽 처리에 매우 유리함 

## 자바 17 [표준] 
- Records: 불변 데이터 객체를 생성할 때 Lombok 없이도 간결한 DTO 정의가 가능
- Sealed Classess (`sealed`): 상속 가능한 클래스를 명시적으로 제한. => '닫힌 계층 구조'
- Pattern Matching: `instanceof` 사용시 자동으로 형 변환 처리
- 텍스트 블록의 추가

## 자바 25 
- 가상 스레드 Virtual Threads:
  - 이전: OS 스레드랑 1:1 매핑이 되었었음. -> 그러다 보니 생성 비용이 높고 컨텍스트 스위칭 비용이 크다
  - 이후: OS 스레드와 N:1 매핑이 되다 보니 수백만 개의 스레드를 가볍게 생성할 수 있게 되었음
- 구조화된 동시성: 멀티 스레드 작업을 하나의 단위로 묶어서 에러 처리와 취소를 명확하게 관리함 
- Project Valhalla: 객체 헤더 오버헤드를 줄이고 메모리 레이아웃을 최적화하는 값 객체의 구체화 


