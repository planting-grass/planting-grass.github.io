---
title: CS
author: 김희원
date: 2026-01-30
category: TIL/김희원/2026/01
layout: post
---

# TCP: 혼잡제어 

> [!NOTE]
> TCP는 오류 + 흐름 + 혼잡 제어를 하는 것으로 유명하다. 
> 그렇다면 어떻게 해낼까?
> - 오류 제어 → 일단 다시 보내보자
> - 흐름 제어 → 처리할 수 있는 만큼만 하자 [수신 호스트]
> - **혼잡 제어 → 네트워크가 혼잡하면 전송하는 양을 조절하자** [송신 호스트] ****

혼잡하다는 건 너무 많은 트래픽 때문에 네트워크가 혼잡해져서 패킷이 처리되는 속도가 느려지거나 유실될 수 있는 상황을 얘기한다.

예를 들어서 모든 호스트가 하나의 라우터한테 전송 가능한 최대 양으로 세그먼트를 전송한다고 생각해보자. 분명 라우터는 과부하가 걸릴 것. 그러면 유실되는 세그먼트도 있겠지? 그것들에 대한 오류 제어도 하다보면 네트워크 상에는 트래픽이 더 날뛸 것. 

결국 네트워크 상에 너무 많은 패킷이 날라다니면 혼잡해져서 안된다는 것임. 그럼 혼잡해지는 걸 막을 수 있는 건 보내는 이, **송신 호스트**가 되겠지? 

**그럼 어떻게 혼잡 제어를 할까?** 

- **혼잡 윈도우 (cwnd)** 라는 개념이 여기서 나온다.
- 송신 호스트가 전송할 수 있을 것 같은 데이터 크기를 얘기함
    - 그니까 “이 정도 양은 송신해도 혼잡 없이 전송가능하겠지?”의 로직이 됨
    - 혼잡 윈도우가 작다고 하면 네트워크가 복작복작한 거고, 혼잡 윈도우가 크다고 하면 네트워크가 여유롭단 뜻

**그럼 이런 혼잡 윈도우의 크기는 송신 호스트가 어떻게 결정할까?**

- 혼잡 윈도우의 크기는 송신 호스트가 네트워크를 보면서 알아서 판단해야 하는 크기임.
    - 그래서 헤더에 포함될 이유가 없는 것이기도 함
    - 비교해가며 이해하면 좋은데, 흐름제어에서는 수신 호스트가 TCP 헤더에 달아서 수신 가능한 윈도우 크기를 달아서 보냈었음

**송신 호스트가 알아서 결정해야 한다고 하면 그 크기는 어느 정도가 적당할까?**

- 이게 이제 우리가 흔히 아는 **혼잡 제어 알고리즘**에 대한 개념이 된다.
- AIMD
- 느린 시작
- 혼잡 회피
- 빠른 시작

AIMD 

- 네트워크가 원활해? → cwnd +1씩 천천히 증가
- 네트워크가 혼잡해? → 1/2 크기로 반절 줄임

느린 시작 

- 핵심은 지수적으로 증가한다고 이해하는 것
- cwnd = 1 부터 시작해서 ACK을 받을 때마다 2배씩 늘림
- 그러다가 ssthresh (임계점)에 도달하면 멈추고, 혼잡 회피로 넘어감

혼잡 회피 

- 느린 시작으로 속도가 올랐으니까 여기서는 속도를 조심스럽게 올림
- 그니까 cwnd 가 ssthresh 값이 되면 RTT 왕복시간마다 1씩만 증가시킨다
- 네트워크 혼잡 막으면서 최대 대역폭을 찾아가는 방향이라고 볼 수 있지

빠른 회복 

- 데이터가 유실되었을 때 무조건 1로 돌아가야 하는가?
- 이게 어떻게 데이터가 유실되었느냐에 따라서 대응 방법이 달라지는데
    - 타임아웃 발생 → 네트워크가 막힌 거라 느린 시작으로 돌아감 cwnd = 1
    - 3개의 중복 ACK 가 발생하면 → 특정 패킷 하나만 잃어버린 상태인거라서 1/2 절반으로 줄이는 걸 선택함. 그리고 느린 시작은 안 하고 혼잡 회피로 가버림

> [!NOTE]
> - 느린 시작 -> 혼잡 회피 -> 데이터 유실
> 1. 타임아웃은 느린 시작부터 시작함
> 2. 3개의 중복 ACK는 절반으로 줄였다가 혼잡 회피로 간다
