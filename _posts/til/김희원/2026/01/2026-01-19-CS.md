---
title: CS
author: 김희원
date: 2026-01-19
category: TIL/김희원/2026/01
layout: post
---

# 메모리에 대한 이해와 주의점 

### 메모리

- 프로그램에서 데이터를 저장할 수 있는 공간
- 프로그램 실행 시 OS에서 자동으로 일정 영역을 할당
- 코드 + 데이터 + 스택 + 힙 영역

### 스택 오버플로우와 힙 오버플로우의 차이

| **구분** | **스택 오버플로우 (Stack Overflow)** | **힙 오버플로우 (Heap Overflow)** |
| --- | --- | --- |
| **메모리 특성** | 정적 할당, LIFO (Last In First Out) 구조 | 동적 할당, 자유로운 구조 |
| **발생 위치** | 스택 프레임 (함수 호출 깊이) | 동적 할당된 메모리 블록 (Chunk) |
| **가장 흔한 원인** | **무한 재귀 호출**, 너무 큰 지역 배열 | **메모리 할당 크기보다 긴 데이터 입력** |
| **방향성** | 보통 높은 주소 → 낮은 주소로 자라다가 충돌 | 보통 낮은 주소 → 높은 주소로 자라며 덮어씀 |
| **위험성** | 즉각적인 프로그램 종료 (비교적 발견 쉬움) | 데이터 오염, 잠재적 보안 취약점 (발견 어려움) |
| **공격 대상** | **리턴 주소 (Return Address)** | **함수 포인터, 객체 데이터, 힙 메타데이터** |

### 프로그램이 종료되면 할당된 모든 메모리는 날라간다

이 상황이 위험한 상황인 경우: 

| **구분** | **설명** | **해결책 (Defense)** |
| --- | --- | --- |
| **현상** | 프로그램 종료 시 RAM 데이터 소멸 | 이것은 막을 수 없는 물리적 현상입니다. |
| **위험** | 저장되지 않은 중요 데이터 손실 | **영속성(Persistence) 확보** |
| **대응 1** | 주기적인 자동 저장 (Auto Save) | 파일이나 DB에 수시로 기록 |
| **대응 2** | 트랜잭션 관리 (Transaction) | 작업이 완료되지 않으면 아예 없던 일로 처리(Rollback) |
| **대응 3** | 로그 기록 (Logging) | 메모리가 날아가도 '어떤 행동을 했는지' 기록을 남겨 복구 |

### 데이터 무결성

메모리에 값을 읽고 쓰는 행위는 반드시 동시에 일어나선 안된다 

- 멀티 스레드 환경에서 반드시 고려해야 하는 요소
- lock, unlock으로 데이터 무결성 보장 가능

### 파일, 데이터베이스, 레지스트리의 차이

| **구분** | **파일 (File)** | **데이터베이스 (DB)** | **레지스트리 (Registry)** |
| --- | --- | --- | --- |
| **주 목적** | 일반적인 데이터 저장, 문서, 미디어 | 대용량 데이터 처리, 복잡한 검색, 서비스용 | **Windows 시스템 및 프로그램 설정** 저장 |
| **구조** | 비정형 (Text, Binary 등 자유) | 정형화됨 (Table, Document 등) | 계층형 (Key-Value 트리 구조) |
| **검색 속도** | 느림 (전체를 다 뒤져야 할 수도 있음) | **매우 빠름** (인덱싱 기술 사용) | 빠름 (설정값 조회에 최적화) |
| **접근 방식** | 파일 입출력 함수 (Open/Read/Write) | 쿼리 언어 (SQL) | Windows API, 레지스트리 편집기 |
| **위험성** | 파일 하나 깨지면 그 파일만 못 씀 | 시스템 전체 데이터 무결성이 중요 | **잘못 건드리면 OS 전체 고장** |
