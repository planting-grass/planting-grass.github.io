---
title: TIL
author: 김희원
date: 2026-02-15
category: TIL/김희원/2026/02
layout: post
---
  
# 오늘 푼 문제 
  
- 코딩 테스트 고득점 kit 에서 깊이/너비우선탐색이랑 해시, 완전탐색 하고 있음 
- 타겟 넘버 Lv2
- 네트워크 Lv2
- 게임 맵 최단거리 Lv2
- 단어 변환 Lv3
  
## 자바 배열에 새 요소 추가하는 거 코드 
  
(1) System.arraycopy 이용
  
```java
class Solution {
    public static int[] addElement(int[] original, int newValue) {
        int n = original.length;
        int[] newArray = new int[n + 1]; // 기존 배열보다 1개 더 큰 새 배열 생성
 
        System.arraycopy(original, 0, newArray, 0, n); // 기존 배열 복사
        newArray[n] = newValue; // 새로운 원소 추가
        return newArray;
    }
}
```
  
더 큰 배열을 만들어서 기존 배열을 복사하고 새로운 원소 추가
  
(2) Arrays.copyOf
```java
import java.util.Arrays;
 
class Solution {
    public static int[] addElement(int[] original, int newValue) {
        int[] newArray = Arrays.copyOf(original, original.length + 1); // 기존 배열에서 크기를 1 증가시킨 배열 생성
        newArray[original.length] = newValue; // 새로운 요소 추가
        return newArray;
    }
}
```
  
(3) ArrayList 활용
```java
import java.util.ArrayList;
import java.util.Arrays;
 
class Solution {
    public static int[] addElement(int[] original) {
        ArrayList<Integer> dynamicArray = new ArrayList<>(Arrays.asList(original));
        dynamicArray.add(4);
        
        return dynamicArray;
    }
}
```
  
- 반면 동적 배열은, ArrayList의 내장함수인 add()를 활용하여 쉽게 원소를 추가할 수 있다.

 
## 어떤 방식을 쓰는 게 효율적인가?
 

1️⃣ System.arraycopy() 이용
  
- 전통적인 방법이고, 추가적인 객체 생성이 필요 없다.
- 배열 크기를 변경할 때마다 새 배열을 생성해야 하므로 추후에 또 배열 크기를 변경할 일이 있다면 성능 부담이 있다.
  
2️⃣ Arrays.copyOf() 이용
 
- 내부적으로 System.arraycopy() 를 호출하므로 1번과 성능이 거의 동일하다. (호출 과정에서 아주 약간의 오버헤드)
- 코드는 1번보다 직관적이다.
- 마찬가지로 배열 크기를 변경할 때마다 새 배열을 생성해야 한다.
  

3️⃣ ArrayList 활용
  
- 배열을 추가하는 과정이 편리한 대신 메모리 사용량이 증가한다.
- 여러 번 요소를 추가할 일이 있을 때 적합하다.

  
정리하면, 1번과 2번의 성능은 비슷하고 ( 배열을 복사하는 O(N) 연산 )
  
3번은 메모리 효율성이 떨어지는 대신 배열 크기가 계속 변해야 한다면 3번을 쓰는 게 편하다.

## 정리 
✔ 속도 & 메모리 최적화가 필요하면 System.arraycopy()
  
✔ 가독성과 유지보수를 생각하면 Arrays.copyOf()
  
✔ 유연한 크기 변경이 필요하면 ArrayList
